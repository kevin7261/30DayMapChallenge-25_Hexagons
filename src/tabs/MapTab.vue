<script>
  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * ğŸ—ºï¸ MapTab.vue - D3.js å°ç£åœ°åœ–çµ„ä»¶
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * @fileoverview
   * é€™æ˜¯ä¸€å€‹åŸºæ–¼ D3.js çš„å°ç£åœ°åœ–è¦–è¦ºåŒ–çµ„ä»¶ï¼ŒåŒæ™‚é¡¯ç¤ºç¸£å¸‚ç•Œç·šå’Œç™»é©ç†±ç¶²æ ¼æ•¸æ“šã€‚
   * æœ¬çµ„ä»¶è² è²¬è¼‰å…¥ã€è™•ç†å’Œæ¸²æŸ“å°ç£ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šå’Œç™»é©ç†±ç—…ä¾‹ç¶²æ ¼æ•¸æ“šã€‚
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ“‹ æ ¸å¿ƒåŠŸèƒ½
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * 1. ç¸£å¸‚é‚Šç•Œæ¸²æŸ“ï¼š
   *    âœ“ è¼‰å…¥ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š1140318.geojson
   *    âœ“ ç¹ªè£½æ‰€æœ‰å°ç£ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š
   *
   * 2. ç™»é©ç†±ç¶²æ ¼æ¸²æŸ“ï¼š
   *    âœ“ è¼‰å…¥ dengue_grid_counts_1km_2023_land_only.geojson
   *    âœ“ æ ¹æ“š level å±¬æ€§ç¹ªè£½5ç´šé¢¨éšªç­‰ç´šç¶²æ ¼
   *    âœ“ åªé¡¯ç¤ºç—…ä¾‹æ•¸ > 0 çš„ç¶²æ ¼
   *    âœ“ ä½¿ç”¨5ç´šè‰²ç¥¨ï¼šæ·±è—(1) â†’ ç¶ (2) â†’ é»ƒæ©™(3) â†’ æ©™(4) â†’ ç´…(5)ï¼ˆæœ€ä¸Šå±¤ï¼‰
   *
   * 3. è¦–è¦ºå…ƒç´ ï¼š
   *    âœ“ ç¸£å¸‚ç•Œç·šï¼šæ·ºç°ç´°é‚Šæ¡†ï¼Œç„¡å¡«å……ï¼ˆåº•å±¤ï¼‰
   *    âœ“ ç™»é©ç†±ç¶²æ ¼ï¼š5ç´šè‰²ç¥¨å¡«å……ï¼Œç„¡é‚Šæ¡†ï¼ˆæœ€ä¸Šå±¤ï¼‰
   *    âœ“ ç™½è‰²åœ°åœ–èƒŒæ™¯
   *
   * 4. äº¤äº’åŠŸèƒ½ï¼š
   *    âœ“ æ»¾è¼ªç¸®æ”¾æ§åˆ¶
   *    âœ“ æ‹–å‹•å¹³ç§»å°èˆª
   *    âœ“ æ»‘é¼ æ‡¸åœé¡¯ç¤ºç¶²æ ¼å±¬æ€§è³‡è¨Š
   *    âœ“ ç¶²æ ¼é«˜äº®æ•ˆæœ
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ¨ é…è‰²ä¸»é¡Œ
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ç™½è‰²      #ffffff  â†’ åœ°åœ–èƒŒæ™¯
   * æ·ºç°è‰²    #cccccc  â†’ ç¸£å¸‚é‚Šæ¡†
   * ç„¡å¡«å……    none     â†’ ç¸£å¸‚å€åŸŸ
   * 5ç´šè‰²ç¥¨            â†’ ç™»é©ç†±é¢¨éšªç­‰ç´šï¼ˆæœ€ä¸Šå±¤ï¼‰
   *   Level 1  #1a237e â†’ æ·±è—è‰²
   *   Level 2  #4caf50 â†’ ç¶ è‰²
   *   Level 3  #fbc02d â†’ é»ƒæ©™è‰²
   *   Level 4  #ff6f00 â†’ æ©™è‰²
   *   Level 5  #d32f2f â†’ ç´…è‰²
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ› ï¸ æŠ€è¡“æ£§
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * @requires vue                 - Vue 3.2+ (Composition API)
   * @requires d3                  - D3.js 7.8+ (åœ°åœ–ç¹ªè£½åº«)
   * @requires @/stores/dataStore  - Pinia ç‹€æ…‹ç®¡ç†
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ“ æ•¸æ“šä¾†æº
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šï¼šç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š1140318.geojson
   * ç™»é©ç†±ç¶²æ ¼æ•¸æ“šï¼šdengue_grid_counts_1km_2023_land_only.geojson
   * è·¯å¾‘ï¼špublic/data/geojson/
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ”§ ä½¿ç”¨æ–¹å¼
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * <MapTab @map-ready="handleMapReady" />
   *
   * @event map-ready - åœ°åœ–åˆå§‹åŒ–å®Œæˆæ™‚è§¸ç™¼ï¼Œè¿”å›åœ°åœ–å¯¦ä¾‹
   *
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ğŸ“ ç¶­è­·è€…
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * @author Kevin Cheng
   * @version 4.0.0
   * @since 2024
   * @license MIT
   *
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“¦ ä¾è³´å°å…¥ (Dependencies Import)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Vue 3 æ ¸å¿ƒåŠŸèƒ½
  import { ref, onMounted, onUnmounted, nextTick } from 'vue';

  // D3.js åœ°åœ–åº«
  import * as d3 from 'd3';

  // Pinia ç‹€æ…‹ç®¡ç†
  import { useDataStore } from '@/stores/dataStore';

  // CesiumJS 3D åœ°åœ–åº« - å°‡ä½¿ç”¨ CDN ç‰ˆæœ¬ï¼Œå¾ window.Cesium ç²å–

  // MapLibre GL JS 3D åœ°åœ–åº«
  import maplibregl from 'maplibre-gl';
  import 'maplibre-gl/dist/maplibre-gl.css';

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¯ çµ„ä»¶å®šç¾© (Component Definition)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  export default {
    name: 'MapTab',

    // çµ„ä»¶è§¸ç™¼çš„äº‹ä»¶
    emits: [
      'map-ready', // åœ°åœ–åˆå§‹åŒ–å®Œæˆæ™‚è§¸ç™¼ï¼Œå‚³éåœ°åœ–å¯¦ä¾‹
    ],

    /**
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * ğŸ¬ çµ„ä»¶è¨­ç½®å‡½æ•¸ (Component Setup Function)
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     * ä½¿ç”¨ Vue 3 Composition API è¨­ç½®çµ„ä»¶é‚è¼¯
     *
     * @param {Object} _ - Propsï¼ˆæœ¬çµ„ä»¶ä¸ä½¿ç”¨ï¼‰
     * @param {Object} context - è¨­ç½®ä¸Šä¸‹æ–‡
     * @param {Function} context.emit - äº‹ä»¶è§¸ç™¼å‡½æ•¸
     * @returns {Object} è¿”å›æ¨¡æ¿å¯ç”¨çš„éŸ¿æ‡‰å¼æ•¸æ“šå’Œæ–¹æ³•
     */
    setup(_, { emit }) {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ“¦ ç‹€æ…‹ç®¡ç†èˆ‡ä¾è³´ (State Management & Dependencies)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Pinia æ•¸æ“šå­˜å„²ï¼ˆä¿ç•™ä¾›æœªä¾†æ“´å±•ä½¿ç”¨ï¼‰
      // eslint-disable-next-line no-unused-vars
      const dataStore = useDataStore();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ—ºï¸ åœ°åœ–ç›¸é—œè®Šæ•¸ (Map-Related Variables)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      /**
       * åœ°åœ– DOM å®¹å™¨å¼•ç”¨
       * @type {Ref<HTMLElement|null>}
       */
      const mapContainer = ref(null);

      /**
       * D3.js SVG å…ƒç´ 
       * @type {d3.Selection|null}
       */
      let svg = null;

      /**
       * D3.js æŠ•å½±å‡½æ•¸
       * @type {d3.GeoProjection|null}
       */
      let projection = null;

      /**
       * D3.js è·¯å¾‘ç”Ÿæˆå™¨
       * @type {d3.GeoPath|null}
       */
      let path = null;

      /**
       * D3.js ç¸®æ”¾è¡Œç‚º
       * @type {d3.ZoomBehavior|null}
       */
      let zoom = null;

      /**
       * SVG ä¸»å®¹å™¨çµ„
       * @type {d3.Selection|null}
       */
      let g = null;

      /**
       * å·¥å…·æç¤ºå…ƒç´ 
       * @type {HTMLElement|null}
       */
      let tooltip = null;

      /**
       * CesiumJS Viewer å¯¦ä¾‹
       * @type {any|null}
       */
      let cesiumViewer = null;

      /**
       * MapLibre GL Map å¯¦ä¾‹
       * @type {maplibregl.Map|null}
       */
      let maplibreMap = null;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ›ï¸ æ§åˆ¶ç‹€æ…‹ (Control States)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      /**
       * åœ°åœ–å°±ç·’ç‹€æ…‹æ¨™è¨˜
       * true = åœ°åœ–å·²åˆå§‹åŒ–å®Œæˆï¼Œfalse = å°šæœªåˆå§‹åŒ–
       * @type {Ref<boolean>}
       */
      const isMapReady = ref(false);

      /**
       * åœ°åœ–å®¹å™¨å”¯ä¸€ ID
       * ä½¿ç”¨éš¨æ©Ÿå­—ç¬¦ä¸²ç¢ºä¿å¤šå¯¦ä¾‹æ™‚ä¸æœƒè¡çª
       * @type {Ref<string>}
       */
      const mapContainerId = ref(`leaflet-map-${Math.random().toString(36).substr(2, 9)}`);

      /**
       * é¡¯ç¤ºæ¨¡å¼
       * 'map' = ä½¿ç”¨åœ°åœ–æŠ•å½±é¡¯ç¤ºï¼ˆç›®å‰çµæœï¼‰
       * 'grid' = ç›´æ¥ä½¿ç”¨ grid_x, grid_y ç¹ªè£½ç¶²æ ¼
       * @type {Ref<string>}
       */
      const displayMode = ref('map');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ“Š GeoJSON æ•¸æ“šå„²å­˜ (GeoJSON Data Storage)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      /**
       * ç¸£å¸‚ GeoJSON æ•¸æ“š
       * ä¾†æºï¼šç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š1140318.geojson
       * @type {Ref<Object|null>}
       */
      const countyData = ref(null);

      /**
       * å…­è§’å½¢ç¶²æ ¼ GeoJSON æ•¸æ“š
       * ä¾†æºï¼špointy_final_with_levels_over5.geojson
       * @type {Ref<Object|null>}
       */
      const hexData = ref(null);

      /**
       * å…­è§’å½¢ç¶²æ ¼ GeoJSON æ•¸æ“š (æ¨¡å¼2)
       * ä¾†æºï¼šhex_grid_pointy_with_population.geojson
       * @type {Ref<Object|null>}
       */
      const hexData2 = ref(null);
      const hexData2Stats = ref({
        min: null,
        max: null,
        positiveCount: 0,
      });
      const hexData2Breaks = ref([]);
      const prideColors = [
        '#750787', // Violet
        '#004DFF', // Blue
        '#008026', // Green
        '#FFED00', // Yellow
        '#FF8C00', // Orange
        '#E40303', // Red
      ];
      const createPrideGradientScale = (minVal, maxVal) => {
        const safeMin = Number.isFinite(minVal) ? minVal : 0;
        let safeMax = Number.isFinite(maxVal) ? maxVal : safeMin;
        if (safeMax <= safeMin) {
          safeMax = safeMin === 0 ? 1 : safeMin + Math.abs(safeMin) * 0.01;
        }
        const step = prideColors.length - 1;
        const domain = prideColors.map(
          (_, index) => safeMin + ((safeMax - safeMin) / step) * index
        );
        return d3.scaleLinear().domain(domain).range(prideColors).clamp(true);
      };

      /**
       * ç™»é©ç†±ç¶²æ ¼ GeoJSON æ•¸æ“šï¼ˆä¿ç•™ä»¥å…¼å®¹ï¼‰
       * ä¾†æºï¼šdengue_grid_counts_1km_2023_land_only.geojson
       * @type {Ref<Object|null>}
       */
      const dengueData = ref(null);

      /**
       * ğŸ“¥ è¼‰å…¥ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š GeoJSON æ•¸æ“š
       */
      const loadCountyData = async () => {
        try {
          console.log('[MapTab] é–‹å§‹è¼‰å…¥ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š GeoJSON æ•¸æ“š...');

          // è¼‰å…¥ç¸£å¸‚ GeoJSON æª”æ¡ˆ
          const countyResponse = await fetch(
            `${process.env.BASE_URL}data/geojson/ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š1140318.geojson`
          );

          // æª¢æŸ¥éŸ¿æ‡‰
          if (!countyResponse.ok) {
            throw new Error(`ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šæ•¸æ“šè¼‰å…¥å¤±æ•—: HTTP ${countyResponse.status}`);
          }

          // è§£æ JSON
          countyData.value = await countyResponse.json();

          console.log('[MapTab] ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šæ•¸æ“šè¼‰å…¥æˆåŠŸ');
          console.log('  - ç¸£å¸‚æ•¸é‡:', countyData.value.features?.length || 0);

          return true;
        } catch (error) {
          console.error('[MapTab] ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šæ•¸æ“šè¼‰å…¥å¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸ› ï¸ å‰µå»ºå·¥å…·æç¤ºå…ƒç´ 
       */
      const createTooltip = () => {
        if (!mapContainer.value) return;

        // ç§»é™¤å·²å­˜åœ¨çš„å·¥å…·æç¤º
        const existingTooltip = mapContainer.value.querySelector('.map-tooltip');
        if (existingTooltip) {
          existingTooltip.remove();
        }

        // å‰µå»ºæ–°çš„å·¥å…·æç¤ºå…ƒç´ 
        tooltip = document.createElement('div');
        tooltip.className = 'map-tooltip';
        tooltip.style.position = 'absolute';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.opacity = '0';
        tooltip.style.padding = '4px 8px';

        mapContainer.value.appendChild(tooltip);
        console.log('[MapTab] å·¥å…·æç¤ºå…ƒç´ å‰µå»ºæˆåŠŸ');
      };

      /**
       * ğŸ“¥ è¼‰å…¥å…­è§’å½¢ç¶²æ ¼ GeoJSON æ•¸æ“š
       */
      const loadHexData = async () => {
        try {
          console.log('[MapTab] é–‹å§‹è¼‰å…¥å…­è§’å½¢ç¶²æ ¼ GeoJSON æ•¸æ“š...');

          // è¼‰å…¥å…­è§’å½¢ç¶²æ ¼ GeoJSON æª”æ¡ˆ
          const hexResponse = await fetch(
            `${process.env.BASE_URL}data/geojson/pointy_final_with_levels_over5.geojson`
          );

          // æª¢æŸ¥éŸ¿æ‡‰
          if (!hexResponse.ok) {
            throw new Error(`å…­è§’å½¢ç¶²æ ¼æ•¸æ“šè¼‰å…¥å¤±æ•—: HTTP ${hexResponse.status}`);
          }

          // è§£æ JSON
          hexData.value = await hexResponse.json();

          console.log('[MapTab] å…­è§’å½¢ç¶²æ ¼æ•¸æ“šè¼‰å…¥æˆåŠŸ');
          console.log('  - ç¶²æ ¼æ•¸é‡:', hexData.value.features?.length || 0);

          return true;
        } catch (error) {
          console.error('[MapTab] å…­è§’å½¢ç¶²æ ¼æ•¸æ“šè¼‰å…¥å¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸ“¥ è¼‰å…¥å…­è§’å½¢ç¶²æ ¼ GeoJSON æ•¸æ“š (æ¨¡å¼2)
       */
      const loadHexData2 = async () => {
        try {
          console.log('[MapTab] é–‹å§‹è¼‰å…¥å…­è§’å½¢ç¶²æ ¼ GeoJSON æ•¸æ“š (æ¨¡å¼2)...');

          const hexResponse = await fetch(
            `${process.env.BASE_URL}data/geojson/hex_grid_pointy_with_population.geojson`
          );

          if (!hexResponse.ok) {
            throw new Error(`å…­è§’å½¢ç¶²æ ¼æ•¸æ“š (æ¨¡å¼2) è¼‰å…¥å¤±æ•—: HTTP ${hexResponse.status}`);
          }

          hexData2.value = await hexResponse.json();

          const features = Array.isArray(hexData2.value?.features) ? hexData2.value.features : [];
          const positiveValues = features
            .map((feature) => Number(feature?.properties?.['æœ‰å¶_ç›¸åŒæ€§åˆ¥_ç¸½è¨ˆ']) || 0)
            .filter((value) => Number.isFinite(value) && value > 0);

          const min = positiveValues.length > 0 ? Math.min(...positiveValues) : 0;
          const max = positiveValues.length > 0 ? Math.max(...positiveValues) : 0;
          hexData2Stats.value = {
            min,
            max,
            positiveCount: positiveValues.length,
          };

          console.log('[MapTab] å…­è§’å½¢ç¶²æ ¼æ•¸æ“š (æ¨¡å¼2) è¼‰å…¥æˆåŠŸ');
          console.log('  - ç¶²æ ¼æ•¸é‡:', features.length);
          console.log('  - æœ‰æ•ˆæ•¸é‡ï¼ˆæ•¸å€¼ > 0ï¼‰:', positiveValues.length);
          console.log('  - æ•¸å€¼ç¯„åœ:', { min, max });

          ensureHexData2Levels();

          return true;
        } catch (error) {
          console.error('[MapTab] å…­è§’å½¢ç¶²æ ¼æ•¸æ“š (æ¨¡å¼2) è¼‰å…¥å¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸ“Š è¨ˆç®—è‡ªç„¶åˆ†ç´š (Jenks Natural Breaks)
       */
      const calculateNaturalBreaks = (values, classCount) => {
        if (!Array.isArray(values) || values.length === 0) {
          return null;
        }

        const sorted = values.filter((value) => Number.isFinite(value)).sort((a, b) => a - b);

        if (sorted.length === 0) {
          return null;
        }

        const uniqueValues = Array.from(new Set(sorted));
        if (uniqueValues.length <= classCount) {
          const breaks = [uniqueValues[0]];
          for (let i = 1; i < uniqueValues.length; i += 1) {
            breaks.push(uniqueValues[i]);
          }
          while (breaks.length < classCount + 1) {
            breaks.push(uniqueValues[uniqueValues.length - 1]);
          }
          return breaks;
        }

        const lowerClassLimits = Array(sorted.length + 1)
          .fill(0)
          .map(() => Array(classCount + 1).fill(0));
        const varianceCombinations = Array(sorted.length + 1)
          .fill(0)
          .map(() => Array(classCount + 1).fill(0));

        for (let i = 1; i <= classCount; i += 1) {
          lowerClassLimits[1][i] = 1;
          varianceCombinations[1][i] = 0;
          for (let j = 2; j <= sorted.length; j += 1) {
            varianceCombinations[j][i] = Infinity;
          }
        }

        const sum = Array(sorted.length + 1).fill(0);
        const sumSquares = Array(sorted.length + 1).fill(0);

        for (let i = 1; i <= sorted.length; i += 1) {
          const val = sorted[i - 1];
          sum[i] = sum[i - 1] + val;
          sumSquares[i] = sumSquares[i - 1] + val * val;
          varianceCombinations[i][1] = sumSquares[i] - (sum[i] * sum[i]) / i;
          lowerClassLimits[i][1] = 1;
        }

        for (let classes = 2; classes <= classCount; classes += 1) {
          for (let item = classes; item <= sorted.length; item += 1) {
            let variance = Infinity;
            let bestLowerClass = classes - 1;

            for (let i = item; i >= classes; i -= 1) {
              const count = item - i + 1;
              const sumRange = sum[item] - sum[i - 1];
              const sumSquaresRange = sumSquares[item] - sumSquares[i - 1];
              const currentVariance = sumSquaresRange - (sumRange * sumRange) / count;

              if (currentVariance < 0) {
                continue;
              }

              const totalVariance = currentVariance + varianceCombinations[i - 1][classes - 1];

              if (totalVariance < variance) {
                variance = totalVariance;
                bestLowerClass = i;
              }
            }

            varianceCombinations[item][classes] = variance;
            lowerClassLimits[item][classes] = bestLowerClass;
          }
        }

        const breaks = Array(classCount + 1).fill(0);
        breaks[classCount] = sorted[sorted.length - 1];

        let count = classCount;
        let k = sorted.length;

        while (count > 0) {
          const idx = lowerClassLimits[k][count];
          breaks[count - 1] = sorted[idx - 1];
          k = idx - 1;
          count -= 1;
        }

        breaks[0] = sorted[0];

        for (let i = 1; i < breaks.length; i += 1) {
          if (breaks[i] < breaks[i - 1]) {
            breaks[i] = breaks[i - 1];
          }
        }

        return breaks;
      };

      /**
       * ğŸ·ï¸ å°‡è‡ªç„¶åˆ†ç´šçµæœæŒ‡æ´¾çµ¦ features
       */
      const assignLevelsToFeatures = (features, breaks) => {
        if (!Array.isArray(features) || !Array.isArray(breaks) || breaks.length < 2) {
          return;
        }

        features.forEach((feature) => {
          const value = Number(feature?.properties?.['æœ‰å¶_ç›¸åŒæ€§åˆ¥_ç¸½è¨ˆ']) || 0;
          let level = 0;
          if (value > 0) {
            for (let i = 0; i < breaks.length - 1; i += 1) {
              const lower = breaks[i];
              const upper = breaks[i + 1];
              if (value >= lower && value <= upper) {
                level = i + 1;
                break;
              }
            }
          }
          feature.properties = {
            ...feature.properties,
            pride_level: level,
          };
        });
      };

      /**
       * â™»ï¸ ç¢ºä¿æ¨¡å¼2è³‡æ–™å…·å‚™å…­è‰²ç­‰ç´š
       */
      const ensureHexData2Levels = () => {
        if (!hexData2.value || !Array.isArray(hexData2.value.features)) {
          console.warn('[MapTab] ensureHexData2Levels: hexData2 å°šæœªè¼‰å…¥æˆ–æ ¼å¼ä¸æ­£ç¢º');
          return;
        }

        const features = hexData2.value.features;
        const values = features
          .map((feature) => Number(feature?.properties?.['æœ‰å¶_ç›¸åŒæ€§åˆ¥_ç¸½è¨ˆ']) || 0)
          .filter((value) => Number.isFinite(value) && value > 0);

        if (values.length === 0) {
          console.warn('[MapTab] ensureHexData2Levels: ç„¡æ­£å€¼å¯ä¾›åˆ†ç´š');
          hexData2Breaks.value = [];
          assignLevelsToFeatures(features, []);
          return;
        }

        const classCount = prideColors.length;
        const breaks = calculateNaturalBreaks(values, classCount);

        if (!breaks) {
          console.warn('[MapTab] ensureHexData2Levels: ç„¡æ³•è¨ˆç®—è‡ªç„¶åˆ†ç´šï¼Œæ¡ç”¨ç­‰è·åˆ†ç´š');
          const min = Math.min(...values);
          const max = Math.max(...values);
          const step = (max - min) / classCount;
          const fallbackBreaks = [min];
          for (let i = 1; i <= classCount; i += 1) {
            fallbackBreaks.push(min + step * i);
          }
          hexData2Breaks.value = fallbackBreaks;
          assignLevelsToFeatures(features, fallbackBreaks);
          return;
        }

        hexData2Breaks.value = breaks;
        assignLevelsToFeatures(features, breaks);
        console.log('[MapTab] ensureHexData2Levels: è¨ˆç®—å®Œæˆ', breaks);
      };

      /**
       * ğŸ“¥ è¼‰å…¥ç™»é©ç†±ç¶²æ ¼ GeoJSON æ•¸æ“š
       */
      // eslint-disable-next-line no-unused-vars
      const loadDengueData = async () => {
        try {
          console.log('[MapTab] é–‹å§‹è¼‰å…¥ç™»é©ç†±ç¶²æ ¼ GeoJSON æ•¸æ“š...');

          // è¼‰å…¥ç™»é©ç†±ç¶²æ ¼ GeoJSON æª”æ¡ˆ
          const dengueResponse = await fetch(
            `${process.env.BASE_URL}data/geojson/dengue_grid_counts_1km_2023_land_only.geojson`
          );

          // æª¢æŸ¥éŸ¿æ‡‰
          if (!dengueResponse.ok) {
            throw new Error(`ç™»é©ç†±ç¶²æ ¼æ•¸æ“šè¼‰å…¥å¤±æ•—: HTTP ${dengueResponse.status}`);
          }

          // è§£æ JSON
          dengueData.value = await dengueResponse.json();

          console.log('[MapTab] ç™»é©ç†±ç¶²æ ¼æ•¸æ“šè¼‰å…¥æˆåŠŸ');
          console.log('  - ç¶²æ ¼æ•¸é‡:', dengueData.value.features?.length || 0);

          return true;
        } catch (error) {
          console.error('[MapTab] ç™»é©ç†±ç¶²æ ¼æ•¸æ“šè¼‰å…¥å¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸ—ºï¸ ç¹ªè£½ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š
       */
      const drawCounties = () => {
        if (!g || !countyData.value) {
          console.error(
            '[MapTab] ç„¡æ³•ç¹ªè£½ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š: g=',
            !!g,
            'countyData=',
            !!countyData.value
          );
          return;
        }

        try {
          console.log('[MapTab] é–‹å§‹ç¹ªè£½ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š GeoJSON');

          // ç¹ªè£½æ‰€æœ‰ç¸£å¸‚
          g.selectAll('.county')
            .data(countyData.value.features)
            .enter()
            .append('path')
            .attr('d', path)
            .attr('class', 'county')
            .attr('fill', 'none') // ä¸å¡«å……
            .attr('stroke', '#cccccc') // æ·ºç°è‰²é‚Šæ¡†
            .attr('stroke-width', 0.5)
            .attr('stroke-opacity', 0.6);

          console.log('[MapTab] ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š GeoJSON ç¹ªè£½å®Œæˆ');
        } catch (error) {
          console.error('[MapTab] ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·š GeoJSON ç¹ªè£½å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ—ï¸ å‰µå»ºç¶²æ ¼ç•«å¸ƒï¼ˆä¸ä¾è³´åœ°åœ–æŠ•å½±ï¼‰
       * ç”¨æ–¼ grid æ¨¡å¼ï¼Œç›´æ¥ä½¿ç”¨ grid_x, grid_y ç¹ªè£½
       */
      // eslint-disable-next-line no-unused-vars
      const createGridCanvas = () => {
        if (!mapContainer.value) return false;

        const rect = mapContainer.value.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          console.warn('[MapTab] å®¹å™¨å°ºå¯¸ç‚ºé›¶ï¼Œå»¶é²åˆå§‹åŒ–');
          return false;
        }

        try {
          // æ¸…é™¤èˆŠçš„ SVG
          if (svg) {
            // å®Œå…¨ç§»é™¤ zoom è¡Œç‚º
            try {
              if (zoom) {
                svg.on('.zoom', null);
                svg.call(zoom.on('zoom', null));
              }
            } catch (e) {
              console.warn('[MapTab] ç§»é™¤ zoom è¡Œç‚ºæ™‚å‡ºéŒ¯:', e);
            }
            svg.remove();
            svg = null;
            g = null;
            zoom = null;
          }

          const width = rect.width;
          const height = rect.height;

          // å‰µå»º SVG å…ƒç´ ï¼ˆä¸å¸¶åœ°åœ–æŠ•å½±ï¼‰
          svg = d3
            .select(mapContainer.value)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('background', '#ffffff'); // ç™½è‰²èƒŒæ™¯

          // å‰µå»ºå®¹å™¨çµ„ï¼ˆä¸ä½¿ç”¨åœ°åœ–æŠ•å½±ï¼‰
          g = svg.append('g');

          // è¨­ç½®ç¸®æ”¾è¡Œç‚ºï¼ˆç”¨æ–¼ç¶²æ ¼ç¸®æ”¾ï¼‰
          zoom = d3
            .zoom()
            .scaleExtent([0.5, 50]) // å…è¨±ç¸®æ”¾ 0.5x åˆ° 50x
            .on('zoom', (event) => {
              if (g && g.node() && g.node().parentNode) {
                g.attr('transform', event.transform);
              }
            });

          svg.call(zoom);

          // é‡ç½®ç¸®æ”¾ç‹€æ…‹ï¼Œç¢ºä¿åˆ‡æ›æ¨¡å¼æ™‚ä¸æœƒå—åˆ°ä¹‹å‰æ¨¡å¼çš„å½±éŸ¿
          svg.call(zoom.transform, d3.zoomIdentity);

          // å‰µå»ºå·¥å…·æç¤ºå…ƒç´ 
          createTooltip();

          isMapReady.value = true;

          console.log('[MapTab] ç¶²æ ¼ç•«å¸ƒå‰µå»ºæˆåŠŸ');
          return true;
        } catch (error) {
          console.error('[MapTab] ç¶²æ ¼ç•«å¸ƒå‰µå»ºå¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸ—ºï¸ ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆGrid æ¨¡å¼ç‰ˆæœ¬ï¼‰
       * ä½¿ç”¨åœ°åœ–æŠ•å½±ï¼Œä½†æ²’æœ‰ç¸£å¸‚ç•Œç·š
       */
      const drawHexGridOnly = () => {
        if (!g || !hexData.value || !path) {
          console.error(
            '[MapTab] ç„¡æ³•ç¹ªè£½å…­è§’å½¢ç¶²æ ¼: g=',
            !!g,
            'hexData=',
            !!hexData.value,
            'path=',
            !!path
          );
          return;
        }

        try {
          console.log('[MapTab] é–‹å§‹ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆGrid æ¨¡å¼ï¼‰');

          // å…ˆæ¸…é™¤èˆŠçš„åœ–å±¤ï¼ˆåŒ…æ‹¬ç¸£å¸‚ç•Œç·šï¼‰
          g.selectAll('.hex-grid').remove();
          g.selectAll('.county').remove();

          // éæ¿¾æ‰äººå£æ•¸ç‚º0æˆ–ratio_Chinaç‚º0æˆ–æ²’æœ‰levelçš„å€åŸŸ
          const validFeatures = hexData.value.features.filter(
            (d) =>
              d.properties['äººå£æ•¸'] &&
              d.properties['äººå£æ•¸'] > 0 &&
              d.properties['ratio_China'] &&
              d.properties['ratio_China'] > 0 &&
              d.properties['level'] &&
              d.properties['level'] >= 1 &&
              d.properties['level'] <= 5
          );

          console.log('[MapTab] ä½¿ç”¨ level åˆ†é¡æ•¸æ“š:', {
            total: hexData.value.features.length,
            valid: validFeatures.length, // äººå£æ•¸ > 0 ä¸” ratio_China > 0 ä¸”æœ‰ level
          });

          // é¡è‰²æ–¹æ¡ˆï¼š5ç´šï¼ŒåŸºæ–¼ä¸­åœ‹åœ‹æ——ç´…è‰² #DE2910 çš„æ¼¸è®Šï¼ˆæ·ºâ†’æ·±ï¼‰
          const colors = [
            '#f9d5d3', // level 1 - å¾ˆæ·ºï¼ˆä¸­åœ‹ç´…çš„æ·¡åŒ–ç‰ˆï¼‰
            '#f4a9a3', // level 2 - æ·º
            '#ee6c5e', // level 3 - ä¸­
            '#de2910', // level 4 - ä¸­åœ‹åœ‹æ——ç´…
            '#a51f0c', // level 5 - æ·±ï¼ˆä¸­åœ‹ç´…çš„æ·±åŒ–ç‰ˆï¼‰
          ];

          // é¡è‰²æ˜ å°„å‡½æ•¸ï¼šç›´æ¥æ ¹æ“š level (1-5) è¿”å›é¡è‰²
          const getColor = (level) => {
            if (!level || level < 1 || level > 5) return '#f0f0f0'; // ç„¡æ•¸æ“šçš„é¡è‰²
            return colors[level - 1]; // level 1-5 å°æ‡‰ colors[0-4]
          };

          // è¨ˆç®—å„ç´šæ•¸é‡ï¼ˆæ ¹æ“š level çµ±è¨ˆï¼‰
          const classCounts = new Array(colors.length).fill(0);
          validFeatures.forEach((d) => {
            const level = d.properties['level'];
            if (level >= 1 && level <= 5) {
              classCounts[level - 1]++; // level 1-5 å°æ‡‰ classCounts[0-4]
            }
          });

          // æŒ‰ level æ’åºï¼ˆåªè€ƒæ…®äººå£æ•¸ > 0 ä¸” ratio_China > 0 ä¸”æœ‰ level çš„å€åŸŸï¼‰
          const sortedHexes = validFeatures.sort((a, b) => {
            const levelA = a.properties['level'] || 0;
            const levelB = b.properties['level'] || 0;
            return levelA - levelB;
          });

          console.log('[DEBUG] Grid æ¨¡å¼ - ç¸½å…±è¦ç¹ªè£½çš„å…­è§’å½¢ç¶²æ ¼æ•¸:', sortedHexes.length);
          console.log(
            '[DEBUG] Grid æ¨¡å¼ - å‰ 5 å€‹ç¶²æ ¼:',
            sortedHexes.slice(0, 5).map((d) => ({
              level: d.properties['level'],
              ratio_China: d.properties['ratio_China'],
              color: getColor(d.properties['level']),
            }))
          );

          // ç¹ªè£½æ‰€æœ‰å…­è§’å½¢ç¶²æ ¼
          const hexPaths = g
            .selectAll('.hex-grid')
            .data(sortedHexes)
            .enter()
            .append('path')
            .attr('d', path)
            .attr('class', 'hex-grid')
            .attr('fill', (d) => getColor(d.properties['level']))
            .attr('fill-opacity', 0.8)
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 0.5)
            .style('cursor', 'pointer');

          console.log('[DEBUG] Grid æ¨¡å¼ - ç¹ªè£½äº†å¤šå°‘å€‹ path å…ƒç´ :', hexPaths.size());

          hexPaths
            .on('mouseover', function (event, d) {
              d3.select(this).attr('fill-opacity', 1).attr('stroke-width', 2);
              if (tooltip) {
                const properties = d.properties;
                // æ ¼å¼åŒ–å°æ•¸å€¼ç‚ºæ˜“è®€æ ¼å¼
                const formatValue = (key, value) => {
                  if (value === null || value === undefined) return 'N/A';
                  // å°æ–¼ ratio é–‹é ­çš„æ¬„ä½ï¼Œæ ¼å¼åŒ–ç‚ºå°æ•¸
                  if (key.startsWith('ratio_') && typeof value === 'number') {
                    if (value === 0) return '0';
                    if (value < 0.0001) {
                      return value.toExponential(2);
                    }
                    if (value < 0.01) {
                      return value.toFixed(5);
                    }
                    return value.toFixed(4);
                  }
                  return value;
                };
                // é¡¯ç¤ºæ‰€æœ‰ properties æ¬„ä½
                let tooltipHTML = '';
                Object.keys(properties).forEach((key) => {
                  const value = properties[key];
                  tooltipHTML += `<div><strong>${key}:</strong> ${formatValue(key, value)}</div>`;
                });
                tooltip.innerHTML = tooltipHTML;
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
                tooltip.style.opacity = 1;
              }
            })
            .on('mousemove', function (event) {
              if (tooltip) {
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
              }
            })
            .on('mouseout', function () {
              d3.select(this).attr('fill-opacity', 0.8).attr('stroke-width', 0.5);
              if (tooltip) {
                tooltip.style.opacity = 0;
              }
            });

          // ç¹ªè£½åœ–ä¾‹
          drawLegend(colors, classCounts);

          console.log('[MapTab] å…­è§’å½¢ç¶²æ ¼ï¼ˆGrid æ¨¡å¼ï¼‰ç¹ªè£½å®Œæˆ');
        } catch (error) {
          console.error('[MapTab] å…­è§’å½¢ç¶²æ ¼ç¹ªè£½å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ—ºï¸ ç¹ªè£½ç¶²æ ¼ï¼ˆä½¿ç”¨ grid_x, grid_yï¼Œä¸ä½¿ç”¨åº§æ¨™ï¼‰
       * å®Œå…¨ç¨ç«‹çš„å¯¦ç¾ï¼Œä¸ä¾è³´åœ°åœ–æŠ•å½±
       */
      // eslint-disable-next-line no-unused-vars
      const drawGridOnly = () => {
        if (!g || !dengueData.value) {
          console.error('[MapTab] ç„¡æ³•ç¹ªè£½ç¶²æ ¼: g=', !!g, 'dengueData=', !!dengueData.value);
          return;
        }

        try {
          console.log('[MapTab] é–‹å§‹ç¹ªè£½ç¶²æ ¼ï¼ˆä½¿ç”¨ grid_x, grid_yï¼‰');

          // æ¸…é™¤èˆŠçš„ç¶²æ ¼
          g.selectAll('.dengue-grid').remove();

          // é¡è‰²æ˜ å°„
          const levelColors = {
            0: '#e0e0e0', // æ·¡ç°è‰²ï¼ˆlevel 0ï¼‰
            1: '#1a237e', // æ·±è—è‰²ï¼ˆæ·±è‰²ï¼‰
            2: '#4caf50', // ç¶ è‰²ï¼ˆè¼ƒäº®ï¼‰
            3: '#fbc02d', // é»ƒæ©™è‰²ï¼ˆé‡‘è‰²ï¼‰
            4: '#ff6f00', // æ©™è‰²ï¼ˆæ˜äº®ï¼‰
            5: '#d32f2f', // ç´…è‰²ï¼ˆæ·±è‰²ï¼‰
          };

          // é¡è‰²æ˜ å°„å‡½æ•¸
          const getColorByLevel = (level) => {
            if (level === 0 || level === null || level === undefined) {
              return levelColors[0];
            }
            return levelColors[level] || levelColors[1];
          };

          // é€æ˜åº¦æ˜ å°„å‡½æ•¸
          const getOpacityByLevel = (level) => {
            const levelNum = level || 0;
            const opacityMap = {
              0: 0.5,
              1: 0.7,
              2: 0.75,
              3: 0.8,
              4: 0.85,
              5: 0.9,
            };
            return opacityMap[levelNum] || opacityMap[0];
          };

          // éæ¿¾æœ‰ grid_x å’Œ grid_y çš„æ•¸æ“š
          const gridsWithXY = dengueData.value.features.filter(
            (d) =>
              d.properties.grid_x !== null &&
              d.properties.grid_x !== undefined &&
              d.properties.grid_y !== null &&
              d.properties.grid_y !== undefined
          );

          if (gridsWithXY.length === 0) {
            console.error('[MapTab] ç„¡æ³•æ‰¾åˆ° grid_x æˆ– grid_y å±¬æ€§');
            return;
          }

          // è¨ˆç®— grid_x å’Œ grid_y çš„ç¯„åœ
          const gridXValues = gridsWithXY.map((d) => d.properties.grid_x);
          const gridYValues = gridsWithXY.map((d) => d.properties.grid_y);

          const minX = d3.min(gridXValues);
          const maxX = d3.max(gridXValues);
          const minY = d3.min(gridYValues);
          const maxY = d3.max(gridYValues);

          console.log('[MapTab] Grid ç¯„åœ:', { minX, maxX, minY, maxY });

          // ç²å– SVG å°ºå¯¸
          const svgWidth = +svg.attr('width') || mapContainer.value.getBoundingClientRect().width;
          const svgHeight =
            +svg.attr('height') || mapContainer.value.getBoundingClientRect().height;

          // å‰µå»ºæ¯”ä¾‹å°ºï¼ˆå¸¶æœ‰ä¸€äº›é‚Šè·ï¼‰
          const padding = 50;
          const availableWidth = svgWidth - 2 * padding;
          const availableHeight = svgHeight - 2 * padding;

          // è¨ˆç®— grid ç¯„åœï¼ˆåŒ…æ‹¬é‚Šç•Œï¼‰
          const rangeX = maxX - minX + 1;
          const rangeY = maxY - minY + 1;

          // è¨ˆç®—ç†è«–å–®å…ƒå¤§å°ï¼ˆæ ¹æ“šå¯ç”¨ç©ºé–“å’Œç¯„åœï¼‰
          const cellWidthFromX = availableWidth / rangeX;
          const cellHeightFromY = availableHeight / rangeY;

          // ä½¿ç”¨è¼ƒå°çš„å€¼ä½œç‚ºçµ±ä¸€çš„å–®å…ƒå¤§å°ï¼Œç¢ºä¿æ‰€æœ‰ç¶²æ ¼éƒ½æ˜¯æ­£æ–¹å½¢ä¸”èƒ½å®Œæ•´é¡¯ç¤º
          const cellSize = Math.min(cellWidthFromX, cellHeightFromY);

          // æ ¹æ“šå¯¦éš›å–®å…ƒå¤§å°è¨ˆç®—å¯¦éš›ä½¿ç”¨çš„ç©ºé–“
          const actualWidth = cellSize * rangeX;
          const actualHeight = cellSize * rangeY;

          // è¨ˆç®—å±…ä¸­åç§»é‡
          const offsetX = (svgWidth - actualWidth) / 2;
          const offsetY = (svgHeight - actualHeight) / 2;

          // å‰µå»ºæ¯”ä¾‹å°ºï¼ˆä½¿ç”¨çµ±ä¸€çš„å–®å…ƒå¤§å°ï¼Œä¸¦å±…ä¸­é¡¯ç¤ºï¼‰
          const scaleX = d3
            .scaleLinear()
            .domain([minX, maxX + 1])
            .range([offsetX, offsetX + actualWidth]);
          // Y è»¸ï¼šgrid_y æœ€å°å€¼åœ¨ä¸Šæ–¹ï¼Œæœ€å¤§å€¼åœ¨ä¸‹æ–¹ï¼ˆSVG åæ¨™ç³»ï¼šy=0 åœ¨é ‚éƒ¨ï¼Œå‘ä¸‹éå¢ï¼‰
          const scaleY = d3
            .scaleLinear()
            .domain([minY, maxY + 1])
            .range([offsetY, offsetY + actualHeight]);

          console.log('[MapTab] Grid å–®å…ƒå¤§å°:', {
            cellSize,
            rangeX,
            rangeY,
            cellWidthFromX,
            cellHeightFromY,
          });

          // ç¶²æ ¼å–®å…ƒå¤§å°ï¼ˆçµ±ä¸€ç‚ºæ­£æ–¹å½¢ï¼‰
          const cellWidth = cellSize;
          const cellHeight = cellSize;

          // æŒ‰ level æ’åºï¼šlevel 0 åœ¨åº•å±¤ï¼Œlevel 1-5 åœ¨ä¸Šå±¤
          const sortedGrids = gridsWithXY.sort((a, b) => {
            const levelA = a.properties.level || 0;
            const levelB = b.properties.level || 0;
            return levelA - levelB;
          });

          // ç¹ªè£½ç¶²æ ¼çŸ©å½¢
          g.selectAll('.dengue-grid')
            .data(sortedGrids)
            .enter()
            .append('rect')
            .attr('class', 'dengue-grid')
            .attr('x', (d) => scaleX(d.properties.grid_x))
            .attr('y', (d) => scaleY(d.properties.grid_y))
            .attr('width', cellWidth)
            .attr('height', cellHeight)
            .attr('fill', (d) => getColorByLevel(d.properties.level))
            .attr('fill-opacity', (d) => getOpacityByLevel(d.properties.level))
            .attr('stroke', 'none')
            .style('cursor', 'pointer')
            .on('mouseover', function (event, d) {
              d3.select(this).attr('fill-opacity', 1);
              if (tooltip) {
                const properties = d.properties;
                // æ ¼å¼åŒ–å°æ•¸å€¼ç‚ºæ˜“è®€æ ¼å¼
                const formatValue = (key, value) => {
                  if (value === null || value === undefined) return 'N/A';
                  // å°æ–¼ ratio é–‹é ­çš„æ¬„ä½ï¼Œæ ¼å¼åŒ–ç‚ºå°æ•¸
                  if (key.startsWith('ratio_') && typeof value === 'number') {
                    if (value === 0) return '0';
                    if (value < 0.0001) {
                      return value.toExponential(2);
                    }
                    if (value < 0.01) {
                      return value.toFixed(5);
                    }
                    return value.toFixed(4);
                  }
                  return value;
                };
                // é¡¯ç¤ºæ‰€æœ‰ properties æ¬„ä½
                let tooltipHTML = '';
                Object.keys(properties).forEach((key) => {
                  const value = properties[key];
                  tooltipHTML += `<div><strong>${key}:</strong> ${formatValue(key, value)}</div>`;
                });
                tooltip.innerHTML = tooltipHTML;
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
                tooltip.style.opacity = 1;
              }
            })
            .on('mousemove', function (event) {
              if (tooltip) {
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
              }
            })
            .on('mouseout', function (event, d) {
              const level = d.properties.level || 0;
              d3.select(this).attr('fill-opacity', getOpacityByLevel(level));
              if (tooltip) {
                tooltip.style.opacity = 0;
              }
            });

          console.log('[MapTab] ç¶²æ ¼ç¹ªè£½å®Œæˆ');
          console.log('  - ç¶²æ ¼æ•¸é‡:', sortedGrids.length);
        } catch (error) {
          console.error('[MapTab] ç¶²æ ¼ç¹ªè£½å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ›ï¸ åˆ‡æ›é¡¯ç¤ºæ¨¡å¼
       * @param {string} mode - 'map' æˆ– 'grid'
       */
      const toggleDisplayMode = async (mode) => {
        displayMode.value = mode;
        console.log('[MapTab] åˆ‡æ›é¡¯ç¤ºæ¨¡å¼:', mode);

        if (displayMode.value === 'map') {
          // åœ°åœ–æ¨¡å¼ï¼šéœ€è¦åœ°åœ–æŠ•å½±ï¼Œè¼‰å…¥ç¸£å¸‚ç•Œç·šå’Œå…­è§’å½¢ç¶²æ ¼
          if (!countyData.value) {
            await loadCountyData();
          }
          if (!hexData.value) {
            await loadHexData();
          }

          cleanup3DViews();

          // æ¸…é™¤èˆŠçš„ SVGï¼ˆå¦‚æœå¾å…¶ä»–æ¨¡å¼åˆ‡æ›éä¾†ï¼‰
          if (svg && !projection) {
            // å®Œå…¨ç§»é™¤ zoom è¡Œç‚º
            try {
              if (zoom) {
                svg.on('.zoom', null);
                svg.call(zoom.on('zoom', null));
              }
            } catch (e) {
              console.warn('[MapTab] ç§»é™¤ zoom è¡Œç‚ºæ™‚å‡ºéŒ¯:', e);
            }
            svg.remove();
            svg = null;
            g = null;
            zoom = null;
          }

          if (!projection || !path) {
            // å¦‚æœé‚„æ²’æœ‰å‰µå»ºåœ°åœ–ï¼Œå…ˆå‰µå»º
            const rect = mapContainer.value.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              const width = rect.width;
              const height = rect.height;

              // æ¸…é™¤èˆŠçš„ SVG
              if (svg) {
                // å–æ¶ˆæ‰€æœ‰ zoom äº‹ä»¶ç¶å®š
                if (zoom) {
                  svg.on('.zoom', null);
                  svg.on('mousedown.zoom', null);
                  svg.on('mousemove.zoom', null);
                  svg.on('mouseup.zoom', null);
                  svg.on('touchstart.zoom', null);
                  svg.on('touchmove.zoom', null);
                  svg.on('touchend.zoom', null);
                  svg.on('wheel.zoom', null);
                }
                svg.remove();
                svg = null;
                g = null;
                zoom = null;
              }

              // å‰µå»º SVG å’Œåœ°åœ–æŠ•å½±
              svg = d3
                .select(mapContainer.value)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#ffffff');

              projection = d3
                .geoMercator()
                .center([121, 23.5])
                .scale(12000)
                .translate([width / 2, height / 2]);

              path = d3.geoPath().projection(projection);
              g = svg.append('g');

              zoom = d3
                .zoom()
                .scaleExtent([0.5, 50])
                .on('zoom', (event) => {
                  if (g) {
                    g.attr('transform', event.transform);
                  }
                });

              svg.call(zoom);

              // é‡ç½®ç¸®æ”¾ç‹€æ…‹ï¼Œç¢ºä¿åˆ‡æ›æ¨¡å¼æ™‚ä¸æœƒå—åˆ°ä¹‹å‰æ¨¡å¼çš„å½±éŸ¿
              svg.call(zoom.transform, d3.zoomIdentity);

              createTooltip();
              isMapReady.value = true;
            }
          } else {
            // å¦‚æœå·²ç¶“å‰µå»ºäº†åœ°åœ–ï¼Œé‡ç½®ç¸®æ”¾ç‹€æ…‹
            if (svg && zoom) {
              svg.call(zoom.transform, d3.zoomIdentity);
            }
          }
          // ç¹ªè£½ç¸£å¸‚ç•Œç·šå’Œå…­è§’å½¢ç¶²æ ¼
          drawCounties();
          drawHexGrid();
        } else if (displayMode.value === 'grid') {
          // Grid æ¨¡å¼ï¼šè¼‰å…¥å…­è§’å½¢ç¶²æ ¼æ•¸æ“šï¼Œéœ€è¦åœ°åœ–æŠ•å½±ä¾†ç¹ªè£½
          if (!hexData.value) {
            await loadHexData();
          }
          // æ¸…é™¤ç¸£å¸‚ç•Œç·šæ•¸æ“šï¼ˆä¸éœ€è¦ï¼‰
          countyData.value = null;

          cleanup3DViews();

          // æ¸…é™¤èˆŠçš„ SVGï¼ˆå¦‚æœå¾åœ°åœ–æ¨¡å¼åˆ‡æ›éä¾†ï¼‰
          if (svg && !projection) {
            // å–æ¶ˆ zoom äº‹ä»¶ç¶å®š
            if (zoom) {
              svg.on('.zoom', null);
            }
            svg.remove();
            svg = null;
            g = null;
            zoom = null;
          }

          if (!projection || !path) {
            // å¦‚æœé‚„æ²’æœ‰å‰µå»ºåœ°åœ–ï¼Œå…ˆå‰µå»º
            const rect = mapContainer.value.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              const width = rect.width;
              const height = rect.height;

              // æ¸…é™¤èˆŠçš„ SVG
              if (svg) {
                // å–æ¶ˆæ‰€æœ‰ zoom äº‹ä»¶ç¶å®š
                if (zoom) {
                  svg.on('.zoom', null);
                  svg.on('mousedown.zoom', null);
                  svg.on('mousemove.zoom', null);
                  svg.on('mouseup.zoom', null);
                  svg.on('touchstart.zoom', null);
                  svg.on('touchmove.zoom', null);
                  svg.on('touchend.zoom', null);
                  svg.on('wheel.zoom', null);
                }
                svg.remove();
                svg = null;
                g = null;
                zoom = null;
              }

              // å‰µå»º SVG å’Œåœ°åœ–æŠ•å½±ï¼ˆGrid æ¨¡å¼ä¹Ÿéœ€è¦æŠ•å½±ä¾†ç¹ªè£½å…­è§’å½¢ï¼‰
              svg = d3
                .select(mapContainer.value)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#ffffff');

              projection = d3
                .geoMercator()
                .center([121, 23.5])
                .scale(12000)
                .translate([width / 2, height / 2]);

              path = d3.geoPath().projection(projection);
              g = svg.append('g');

              zoom = d3
                .zoom()
                .scaleExtent([0.5, 50])
                .on('zoom', (event) => {
                  if (g) {
                    g.attr('transform', event.transform);
                  }
                });

              svg.call(zoom);

              // é‡ç½®ç¸®æ”¾ç‹€æ…‹
              svg.call(zoom.transform, d3.zoomIdentity);

              createTooltip();
              isMapReady.value = true;
            }
          } else {
            // å¦‚æœå·²ç¶“å‰µå»ºäº†åœ°åœ–ï¼Œé‡ç½®ç¸®æ”¾ç‹€æ…‹
            if (svg && zoom) {
              svg.call(zoom.transform, d3.zoomIdentity);
            }
          }

          // ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆGrid æ¨¡å¼ï¼Œä¸é¡¯ç¤ºç¸£å¸‚ç•Œç·šï¼‰
          drawHexGridOnly();
        } else if (displayMode.value === 'cesium3d') {
          // CesiumJS 3D æ¨¡å¼
          if (!hexData.value) {
            await loadHexData();
          }
          if (!countyData.value) {
            await loadCountyData();
          }
          // æ¸…ç†èˆŠçš„ SVG æˆ–å…¶ä»–è¦–åœ–
          cleanupOtherViews();
          // åˆå§‹åŒ– CesiumJS 3D åœ°åœ–
          await initCesium3D();
        } else if (displayMode.value === 'maplibre3d') {
          // MapLibre 3D æ¨¡å¼
          if (!hexData.value) {
            await loadHexData();
          }
          if (!countyData.value) {
            await loadCountyData();
          }
          // æ¸…ç†èˆŠçš„ SVG æˆ–å…¶ä»–è¦–åœ–
          cleanupOtherViews();
          // åˆå§‹åŒ– MapLibre 3D åœ°åœ–
          await initMapLibre3D();
        } else if (displayMode.value === 'map2') {
          if (!countyData.value) {
            await loadCountyData();
          }
          if (!hexData2.value) {
            await loadHexData2();
          }

          cleanup3DViews();

          if (svg && !projection) {
            try {
              if (zoom) {
                svg.on('.zoom', null);
                svg.call(zoom.on('zoom', null));
              }
            } catch (e) {
              console.warn('[MapTab] ç§»é™¤ zoom è¡Œç‚ºæ™‚å‡ºéŒ¯:', e);
            }
            svg.remove();
            svg = null;
            g = null;
            zoom = null;
          }

          if (!projection || !path) {
            const rect = mapContainer.value.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              const width = rect.width;
              const height = rect.height;

              if (svg) {
                if (zoom) {
                  svg.on('.zoom', null);
                  svg.on('mousedown.zoom', null);
                  svg.on('mousemove.zoom', null);
                  svg.on('mouseup.zoom', null);
                  svg.on('touchstart.zoom', null);
                  svg.on('touchmove.zoom', null);
                  svg.on('touchend.zoom', null);
                  svg.on('wheel.zoom', null);
                }
                svg.remove();
                svg = null;
                g = null;
                zoom = null;
              }

              svg = d3
                .select(mapContainer.value)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#000000');

              projection = d3
                .geoMercator()
                .center([121, 23.5])
                .scale(12000)
                .translate([width / 2, height / 2]);

              path = d3.geoPath().projection(projection);
              g = svg.append('g');

              zoom = d3
                .zoom()
                .scaleExtent([0.5, 50])
                .on('zoom', (event) => {
                  if (g) {
                    g.attr('transform', event.transform);
                  }
                });

              svg.call(zoom);
              svg.call(zoom.transform, d3.zoomIdentity);

              createTooltip();
              isMapReady.value = true;
            }
          } else if (svg && zoom) {
            svg.call(zoom.transform, d3.zoomIdentity);
            svg.style('background', '#000000');
          }

          drawCounties();
          drawHexGrid2();
        } else if (displayMode.value === 'grid2') {
          if (!hexData2.value) {
            await loadHexData2();
          }
          countyData.value = null;

          cleanup3DViews();

          if (svg && !projection) {
            if (zoom) {
              svg.on('.zoom', null);
            }
            svg.remove();
            svg = null;
            g = null;
            zoom = null;
          }

          if (!projection || !path) {
            const rect = mapContainer.value.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              const width = rect.width;
              const height = rect.height;

              if (svg) {
                if (zoom) {
                  svg.on('.zoom', null);
                  svg.on('mousedown.zoom', null);
                  svg.on('mousemove.zoom', null);
                  svg.on('mouseup.zoom', null);
                  svg.on('touchstart.zoom', null);
                  svg.on('touchmove.zoom', null);
                  svg.on('touchend.zoom', null);
                  svg.on('wheel.zoom', null);
                }
                svg.remove();
                svg = null;
                g = null;
                zoom = null;
              }

              svg = d3
                .select(mapContainer.value)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#000000');

              projection = d3
                .geoMercator()
                .center([121, 23.5])
                .scale(12000)
                .translate([width / 2, height / 2]);

              path = d3.geoPath().projection(projection);
              g = svg.append('g');

              zoom = d3
                .zoom()
                .scaleExtent([0.5, 50])
                .on('zoom', (event) => {
                  if (g) {
                    g.attr('transform', event.transform);
                  }
                });

              svg.call(zoom);
              svg.call(zoom.transform, d3.zoomIdentity);

              createTooltip();
              isMapReady.value = true;
            }
          } else if (svg && zoom) {
            svg.call(zoom.transform, d3.zoomIdentity);
            svg.style('background', '#000000');
          }

          drawHexGridOnly2();
        } else if (displayMode.value === 'cesium3d2') {
          if (!hexData2.value) {
            await loadHexData2();
          } else {
            ensureHexData2Levels();
          }
          if (!countyData.value) {
            await loadCountyData();
          }
          cleanupOtherViews();
          await initCesium3D2();
        } else if (displayMode.value === 'maplibre3d2') {
          if (!hexData2.value) {
            await loadHexData2();
          } else {
            ensureHexData2Levels();
          }
          if (!countyData.value) {
            await loadCountyData();
          }
          cleanupOtherViews();
          await initMapLibre3D2();
        }
      };

      /**
       * ğŸ§¹ åªæ¸…ç† 3D è¦–åœ–ï¼ˆCesium / MapLibreï¼‰ï¼Œä¿ç•™ D3 ç‹€æ…‹
       */
      const cleanup3DViews = () => {
        let cleared = false;

        if (cesiumViewer) {
          try {
            cesiumViewer.destroy();
          } catch (e) {
            console.warn('[MapTab] æ¸…ç† Cesium Viewer æ™‚å‡ºéŒ¯:', e);
          }
          cesiumViewer = null;
          cleared = true;
        }

        if (maplibreMap) {
          try {
            maplibreMap.remove();
          } catch (e) {
            console.warn('[MapTab] æ¸…ç† MapLibre Map æ™‚å‡ºéŒ¯:', e);
          }
          maplibreMap = null;
          cleared = true;
        }

        if (cleared && mapContainer.value) {
          mapContainer.value.innerHTML = '';
          svg = null;
          g = null;
          zoom = null;
          projection = null;
          path = null;
          if (tooltip) {
            tooltip.remove();
            tooltip = null;
          }
        }
      };

      /**
       * ğŸ§¹ æ¸…ç†å…¶ä»–è¦–åœ–ï¼ˆSVGã€Cesiumã€MapLibreï¼‰
       */
      const cleanupOtherViews = () => {
        // æ¸…ç† SVG
        if (svg) {
          try {
            if (zoom) {
              svg.on('.zoom', null);
            }
            svg.remove();
          } catch (e) {
            console.warn('[MapTab] æ¸…ç† SVG æ™‚å‡ºéŒ¯:', e);
          }
          svg = null;
          g = null;
          zoom = null;
          projection = null;
          path = null;
        }

        // æ¸…ç† Cesium Viewer
        if (cesiumViewer) {
          try {
            cesiumViewer.destroy();
          } catch (e) {
            console.warn('[MapTab] æ¸…ç† Cesium Viewer æ™‚å‡ºéŒ¯:', e);
          }
          cesiumViewer = null;
        }

        // æ¸…ç† MapLibre Map
        if (maplibreMap) {
          try {
            maplibreMap.remove();
          } catch (e) {
            console.warn('[MapTab] æ¸…ç† MapLibre Map æ™‚å‡ºéŒ¯:', e);
          }
          maplibreMap = null;
        }

        // æ¸…ç©ºå®¹å™¨
        if (mapContainer.value) {
          mapContainer.value.innerHTML = '';
        }
      };

      /**
       * ğŸŒ åˆå§‹åŒ– CesiumJS 3D åœ°åœ–
       */
      const initCesium3D = async () => {
        try {
          console.log('[MapTab] é–‹å§‹åˆå§‹åŒ– CesiumJS 3D åœ°åœ–');

          if (!mapContainer.value || !hexData.value) {
            console.error('[MapTab] ç„¡æ³•åˆå§‹åŒ– CesiumJS: å®¹å™¨æˆ–æ•¸æ“šä¸å­˜åœ¨');
            return;
          }

          // è¼‰å…¥ç¸£å¸‚ç•Œç·šæ•¸æ“šï¼ˆå¦‚æœå°šæœªè¼‰å…¥ï¼‰
          if (!countyData.value) {
            await loadCountyData();
          }

          // æª¢æŸ¥ Cesium æ˜¯å¦å·²è¼‰å…¥ï¼ˆå¾ CDNï¼‰
          if (typeof window.Cesium === 'undefined') {
            console.error('[MapTab] CesiumJS å°šæœªè¼‰å…¥ï¼Œè«‹ç¢ºä¿å·²å¼•å…¥ CDN è…³æœ¬');
            return;
          }

          // eslint-disable-next-line no-undef
          const Cesium = window.Cesium;

          // è¨­ç½® Cesium Ion è¨ªå•ä»¤ç‰Œ
          Cesium.Ion.defaultAccessToken =
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxYjJiZjlhZC1mZDNkLTRiZWEtYjExNy1iZDI1OWQ5ZmJlZmEiLCJpZCI6MzU1MDgxLCJpYXQiOjE3NjE3MTc5NTl9.ivNUz20WJNOvyTB6vzB8xHNWNSzgl06vBAGOuZLNKs4';

          // å‰µå»ºä¸–ç•Œåœ°å½¢æä¾›è€…ï¼ˆéœ€è¦ Ion tokenï¼‰
          const worldTerrain = await Cesium.createWorldTerrainAsync();

          // å‰µå»º Cesium Viewerï¼ˆä½¿ç”¨ä¸–ç•Œåœ°å½¢ï¼‰
          cesiumViewer = new Cesium.Viewer(mapContainer.value, {
            terrainProvider: worldTerrain,
            baseLayerPicker: false,
            geocoder: false,
            homeButton: false,
            infoBox: true,
            sceneModePicker: false,
            selectionIndicator: false,
            timeline: false,
            animation: false,
            fullscreenButton: false,
            vrButton: false,
            navigationHelpButton: false,
          });

          // è¨­ç½®è¦–è§’åˆ°å°ç£
          cesiumViewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(121.0, 23.5, 500000),
            orientation: {
              heading: 0.0,
              pitch: -0.5,
              roll: 0.0,
            },
          });

          // é¡è‰²æ–¹æ¡ˆï¼šæ ¹æ“š level (1-5) è¿”å›é¡è‰²
          const getColorByLevel = (level) => {
            const colors = {
              1: Cesium.Color.fromCssColorString('#f9d5d3'), // level 1 - å¾ˆæ·º
              2: Cesium.Color.fromCssColorString('#f4a9a3'), // level 2 - æ·º
              3: Cesium.Color.fromCssColorString('#ee6c5e'), // level 3 - ä¸­
              4: Cesium.Color.fromCssColorString('#de2910'), // level 4 - ä¸­åœ‹åœ‹æ——ç´…
              5: Cesium.Color.fromCssColorString('#a51f0c'), // level 5 - æ·±
            };
            return colors[level] || Cesium.Color.fromCssColorString('#f0f0f0');
          };

          // è¨ˆç®—å…­è§’å½¢ç¶²æ ¼çš„å¯¬åº¦ï¼ˆç±³ï¼‰
          // å¾ç¬¬ä¸€å€‹æœ‰æ•ˆçš„å…­è§’å½¢è¨ˆç®—å¯¬åº¦ï¼ˆç›¸å°é ‚é»ä¹‹é–“çš„è·é›¢ï¼‰
          const calculateHexWidth = () => {
            if (!hexData.value || !hexData.value.features || hexData.value.features.length === 0) {
              return 6000; // é»˜èªå€¼ï¼Œå¦‚æœç„¡æ³•è¨ˆç®—
            }

            const firstHex = hexData.value.features.find(
              (f) =>
                f.properties.level >= 1 &&
                f.properties.level <= 5 &&
                f.geometry &&
                f.geometry.coordinates[0]
            );

            if (!firstHex || !firstHex.geometry.coordinates[0]) {
              return 6000; // é»˜èªå€¼
            }

            const coords = firstHex.geometry.coordinates[0];
            if (coords.length < 4) {
              return 6000; // é»˜èªå€¼
            }

            // è¨ˆç®—ç›¸å°é ‚é»ä¹‹é–“çš„è·é›¢ï¼ˆå…­è§’å½¢å¯¬åº¦ï¼‰
            const p1 = coords[0];
            const p4 = coords[3]; // ç›¸å°é ‚é»

            // ä½¿ç”¨ Haversine å…¬å¼è¨ˆç®—è·é›¢ï¼ˆç±³ï¼‰
            const R = 6371000; // åœ°çƒåŠå¾‘ï¼ˆç±³ï¼‰
            const lat1 = (p1[1] * Math.PI) / 180;
            const lat4 = (p4[1] * Math.PI) / 180;
            const dLat = ((p4[1] - p1[1]) * Math.PI) / 180;
            const dLon = ((p4[0] - p1[0]) * Math.PI) / 180;
            const a =
              Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1) * Math.cos(lat4) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const width = R * c;

            console.log('[MapTab] CesiumJS 3D - è¨ˆç®—çš„å…­è§’å½¢å¯¬åº¦ï¼ˆç±³ï¼‰:', width);
            return width;
          };

          const hexWidth = calculateHexWidth();

          // å°‡ level è½‰æ›ç‚ºé«˜åº¦ï¼ˆç±³ï¼‰
          // level 1 çš„é«˜åº¦ = å…­è§’å½¢å¯¬åº¦
          // level 5 çš„é«˜åº¦ = level 1 çš„ 5 å€ = å…­è§’å½¢å¯¬åº¦çš„ 5 å€
          const levelToHeight = (level) => {
            if (!level || level < 1 || level > 5) return 0;
            // level 1 = hexWidth, level 2 = 2 * hexWidth, ..., level 5 = 5 * hexWidth
            return level * hexWidth;
          };

          // éæ¿¾æœ‰æ•ˆçš„ featuresï¼ˆlevel 1-5ï¼‰
          const validFeatures = hexData.value.features.filter(
            (d) =>
              d.properties.level &&
              d.properties.level >= 1 &&
              d.properties.level <= 5 &&
              d.geometry &&
              d.geometry.type === 'Polygon'
          );

          console.log('[MapTab] CesiumJS 3D - æœ‰æ•ˆçš„ features æ•¸é‡:', validFeatures.length);

          // ç¹ªè£½å°ç£ç¸£å¸‚ç•Œç·šï¼ˆç™½è‰²é‚Šæ¡†ï¼‰
          if (countyData.value && countyData.value.features) {
            countyData.value.features.forEach((countyFeature) => {
              if (countyFeature.geometry && countyFeature.geometry.type === 'Polygon') {
                const coordinates = countyFeature.geometry.coordinates[0];
                const positions = coordinates.map((coord) =>
                  Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 0)
                );

                // å‰µå»ºç¸£å¸‚ç•Œç·šï¼ˆç™½è‰²é‚Šæ¡†ï¼Œç„¡å¡«å……ï¼‰
                cesiumViewer.entities.add({
                  polyline: {
                    positions: positions.concat([positions[0]]), // é–‰åˆå¤šé‚Šå½¢
                    width: 2.0,
                    material: Cesium.Color.WHITE.withAlpha(0.8),
                    clampToGround: true, // è²¼åœ°é¡¯ç¤º
                  },
                });
              } else if (countyFeature.geometry && countyFeature.geometry.type === 'MultiPolygon') {
                // è™•ç† MultiPolygon é¡å‹
                countyFeature.geometry.coordinates.forEach((polygon) => {
                  const coordinates = polygon[0];
                  const positions = coordinates.map((coord) =>
                    Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 0)
                  );

                  cesiumViewer.entities.add({
                    polyline: {
                      positions: positions.concat([positions[0]]),
                      width: 2.0,
                      material: Cesium.Color.WHITE.withAlpha(0.8),
                      clampToGround: true,
                    },
                  });
                });
              }
            });
            console.log('[MapTab] CesiumJS 3D - ç¸£å¸‚ç•Œç·šç¹ªè£½å®Œæˆ');
          }

          // ç‚ºæ¯å€‹ feature å‰µå»º 3D æŸ±ç‹€åœ–ï¼ˆé«˜åº¦ç”± level æ±ºå®šï¼‰
          validFeatures.forEach((feature) => {
            const level = feature.properties.level;
            const coordinates = feature.geometry.coordinates[0]; // Polygon çš„ç¬¬ä¸€å€‹ç’°
            const extrudedHeight = levelToHeight(level);

            // å°‡ GeoJSON åº§æ¨™è½‰æ›ç‚º Cesium çš„ Cartesian3 æ•¸çµ„
            // åŸºç¤åº§æ¨™æ‡‰è©²åœ¨åœ°é¢ï¼ˆé«˜åº¦ 0ï¼‰ï¼Œç„¶å¾Œé€šé extrudedHeight å‘ä¸Šæ“ å£“
            const positions = coordinates.map((coord) =>
              Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 0)
            );

            // å‰µå»ºæ“ å£“å¤šé‚Šå½¢å¯¦é«”ï¼ˆæŸ±ç‹€åœ–æ•ˆæœï¼‰
            cesiumViewer.entities.add({
              polygon: {
                hierarchy: positions,
                material: getColorByLevel(level).withAlpha(0.8),
                // æ“ å£“é«˜åº¦ï¼šå¾åœ°é¢ï¼ˆheight=0ï¼‰åˆ°ç›®æ¨™é«˜åº¦ï¼ˆextrudedHeightï¼‰
                height: 0, // åŸºç¤é«˜åº¦ï¼ˆåœ°é¢ï¼‰
                extrudedHeight: extrudedHeight, // æ“ å£“åˆ°çš„é«˜åº¦
                // ä¸é¡¯ç¤ºé‚Šæ¡†
                outline: false,
              },
              properties: feature.properties,
            });
          });

          // æ ¼å¼åŒ– village_list ç‚º HTML
          const formatVillageList = (villageList) => {
            if (!villageList) return 'N/A';

            // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œå˜—è©¦è§£æ
            let villages = villageList;
            if (typeof villageList === 'string') {
              try {
                // å…ˆå˜—è©¦æ¨™æº– JSON è§£æ
                villages = JSON.parse(villageList);
              } catch (e) {
                try {
                  // å¦‚æœæ˜¯ Python æ ¼å¼çš„å­—ç¬¦ä¸²ï¼ˆä½¿ç”¨å–®å¼•è™Ÿï¼‰ï¼Œå…ˆè½‰æ›ç‚ºæ¨™æº– JSON
                  // å°‡å–®å¼•è™Ÿæ”¹ç‚ºé›™å¼•è™Ÿï¼ŒNone æ”¹ç‚º null
                  const jsonString = villageList
                    .replace(/'/g, '"')
                    .replace(/None/g, 'null')
                    .replace(/True/g, 'true')
                    .replace(/False/g, 'false');
                  villages = JSON.parse(jsonString);
                } catch (e2) {
                  return villageList; // å¦‚æœè§£æå¤±æ•—ï¼Œç›´æ¥è¿”å›å­—ç¬¦ä¸²
                }
              }
            }

            // å¦‚æœä¸æ˜¯æ•¸çµ„ï¼Œè¿”å›åŸå€¼
            if (!Array.isArray(villages)) {
              return String(villages);
            }

            // æ ¼å¼åŒ–æ¯å€‹ village é …ç›®
            if (villages.length === 0) return 'ç„¡è³‡æ–™';

            return villages
              .map((village, index) => {
                if (typeof village === 'object' && village !== null) {
                  const items = Object.keys(village)
                    .map((key) => {
                      const val = village[key];
                      const displayVal = val === null || val === undefined ? 'N/A' : val;
                      return `${key}: ${displayVal}`;
                    })
                    .join(', ');
                  return `${index + 1}. ${items}`;
                }
                return `${index + 1}. ${village}`;
              })
              .join('<br>');
          };

          // æ·»åŠ é»æ“Šäº‹ä»¶é¡¯ç¤ºå±¬æ€§ä¿¡æ¯
          const handler = new Cesium.ScreenSpaceEventHandler(cesiumViewer.scene.canvas);
          handler.setInputAction((click) => {
            const pickedObject = cesiumViewer.scene.pick(click.position);
            if (Cesium.defined(pickedObject) && pickedObject.id && pickedObject.id.properties) {
              const properties = pickedObject.id.properties;
              let html = '<div style="max-width: 400px; max-height: 500px; overflow-y: auto;">';

              // é¡¯ç¤ºæ‰€æœ‰å±¬æ€§
              for (const key in properties) {
                if (Object.prototype.hasOwnProperty.call(properties, key)) {
                  const value = properties[key].getValue();

                  if (key === 'village_list' || key === 'villageList') {
                    // ç‰¹æ®Šè™•ç† village_list
                    html += `<div><strong>${key}:</strong><br>${formatVillageList(value)}</div><br>`;
                  } else {
                    html += `<div><strong>${key}:</strong> ${value}</div>`;
                  }
                }
              }

              html += '</div>';

              // ä½¿ç”¨ Cesium InfoBox é¡¯ç¤º
              console.log('[MapTab] CesiumJS - é»æ“Šçš„å¯¦é«”ä¿¡æ¯:', html);

              // é¡¯ç¤ºåœ¨ infoBox ä¸­
              if (cesiumViewer.infoBox && pickedObject.id) {
                cesiumViewer.selectedEntity = pickedObject.id;
                cesiumViewer.infoBox.viewModel.description = html;
              }
            }
          }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

          isMapReady.value = true;
          console.log('[MapTab] CesiumJS 3D åœ°åœ–åˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
          console.error('[MapTab] CesiumJS 3D åœ°åœ–åˆå§‹åŒ–å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ—ºï¸ åˆå§‹åŒ– MapLibre GL 3D åœ°åœ–
       */
      const initMapLibre3D = async () => {
        try {
          console.log('[MapTab] é–‹å§‹åˆå§‹åŒ– MapLibre GL 3D åœ°åœ–');

          if (!mapContainer.value || !hexData.value) {
            console.error('[MapTab] ç„¡æ³•åˆå§‹åŒ– MapLibre GL: å®¹å™¨æˆ–æ•¸æ“šä¸å­˜åœ¨');
            return;
          }

          // è¼‰å…¥ç¸£å¸‚ç•Œç·šæ•¸æ“šï¼ˆå¦‚æœå°šæœªè¼‰å…¥ï¼‰
          if (!countyData.value) {
            await loadCountyData();
          }

          // å‰µå»º MapLibre Mapï¼ˆä½¿ç”¨ Carto Dark åº•åœ–ï¼‰
          maplibreMap = new maplibregl.Map({
            container: mapContainer.value,
            style: {
              version: 8,
              sources: {
                carto: {
                  type: 'raster',
                  tiles: [
                    'https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                    'https://b.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                    'https://c.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                  ],
                  tileSize: 256,
                  attribution:
                    '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                },
              },
              layers: [
                {
                  id: 'carto-dark-layer',
                  type: 'raster',
                  source: 'carto',
                  minzoom: 0,
                  maxzoom: 22,
                },
              ],
            },
            center: [121.0, 23.5], // å°ç£ä¸­å¿ƒ
            zoom: 8,
            pitch: 45, // å‚¾æ–œè§’åº¦ï¼Œå‰µå»º 3D æ•ˆæœ
            bearing: 0,
            antialias: true,
          });

          // ç­‰å¾…åœ°åœ–è¼‰å…¥å®Œæˆ
          maplibreMap.on('load', () => {
            console.log('[MapTab] MapLibre GL åœ°åœ–è¼‰å…¥å®Œæˆ');

            // è¨ˆç®—å…­è§’å½¢ç¶²æ ¼çš„å¯¬åº¦ï¼ˆç±³ï¼‰
            // å¾ç¬¬ä¸€å€‹æœ‰æ•ˆçš„å…­è§’å½¢è¨ˆç®—å¯¬åº¦ï¼ˆç›¸å°é ‚é»ä¹‹é–“çš„è·é›¢ï¼‰
            const calculateHexWidth = () => {
              if (
                !hexData.value ||
                !hexData.value.features ||
                hexData.value.features.length === 0
              ) {
                return 6000; // é»˜èªå€¼ï¼Œå¦‚æœç„¡æ³•è¨ˆç®—
              }

              const firstHex = hexData.value.features.find(
                (f) =>
                  f.properties.level >= 1 &&
                  f.properties.level <= 5 &&
                  f.geometry &&
                  f.geometry.coordinates[0]
              );

              if (!firstHex || !firstHex.geometry.coordinates[0]) {
                return 6000; // é»˜èªå€¼
              }

              const coords = firstHex.geometry.coordinates[0];
              if (coords.length < 4) {
                return 6000; // é»˜èªå€¼
              }

              // è¨ˆç®—ç›¸å°é ‚é»ä¹‹é–“çš„è·é›¢ï¼ˆå…­è§’å½¢å¯¬åº¦ï¼‰
              const p1 = coords[0];
              const p4 = coords[3]; // ç›¸å°é ‚é»

              // ä½¿ç”¨ Haversine å…¬å¼è¨ˆç®—è·é›¢ï¼ˆç±³ï¼‰
              const R = 6371000; // åœ°çƒåŠå¾‘ï¼ˆç±³ï¼‰
              const lat1 = (p1[1] * Math.PI) / 180;
              const lat4 = (p4[1] * Math.PI) / 180;
              const dLat = ((p4[1] - p1[1]) * Math.PI) / 180;
              const dLon = ((p4[0] - p1[0]) * Math.PI) / 180;
              const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1) * Math.cos(lat4) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
              const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
              const width = R * c;

              console.log('[MapTab] MapLibre GL 3D - è¨ˆç®—çš„å…­è§’å½¢å¯¬åº¦ï¼ˆç±³ï¼‰:', width);
              return width;
            };

            const hexWidth = calculateHexWidth();

            // å°‡ level è½‰æ›ç‚ºé«˜åº¦ï¼ˆç±³ï¼‰
            // level 1 çš„é«˜åº¦ = å…­è§’å½¢å¯¬åº¦
            // level 5 çš„é«˜åº¦ = level 1 çš„ 5 å€ = å…­è§’å½¢å¯¬åº¦çš„ 5 å€
            const levelToHeight = (level) => {
              if (!level || level < 1 || level > 5) return 0;
              // level 1 = hexWidth, level 2 = 2 * hexWidth, ..., level 5 = 5 * hexWidth
              return level * hexWidth;
            };

            // é¡è‰²æ–¹æ¡ˆï¼šæ ¹æ“š level (1-5) è¿”å›é¡è‰²
            const getColorByLevel = (level) => {
              const colors = {
                1: '#f9d5d3', // level 1 - å¾ˆæ·º
                2: '#f4a9a3', // level 2 - æ·º
                3: '#ee6c5e', // level 3 - ä¸­
                4: '#de2910', // level 4 - ä¸­åœ‹åœ‹æ——ç´…
                5: '#a51f0c', // level 5 - æ·±
              };
              return colors[level] || '#f0f0f0';
            };

            // æº–å‚™ GeoJSON æ•¸æ“šï¼Œç‚ºæ¯å€‹ feature æ·»åŠ é«˜åº¦å±¬æ€§
            const featuresWithHeight = hexData.value.features
              .filter(
                (d) =>
                  d.properties.level &&
                  d.properties.level >= 1 &&
                  d.properties.level <= 5 &&
                  d.geometry &&
                  d.geometry.type === 'Polygon'
              )
              .map((feature) => {
                const level = feature.properties.level;
                const height = levelToHeight(level);

                // ä¿æŒåŸå§‹åº§æ¨™æ ¼å¼ [lng, lat]ï¼Œé«˜åº¦é€šéå±¬æ€§è¨­ç½®
                return {
                  ...feature,
                  properties: {
                    ...feature.properties,
                    base_height: height,
                    color: getColorByLevel(level),
                  },
                };
              });

            console.log(
              '[MapTab] MapLibre GL 3D - æœ‰æ•ˆçš„ features æ•¸é‡:',
              featuresWithHeight.length
            );

            // æ·»åŠ ç¸£å¸‚ç•Œç·š GeoJSON æº
            if (countyData.value && countyData.value.features) {
              maplibreMap.addSource('county-boundaries', {
                type: 'geojson',
                data: countyData.value,
              });

              // æ·»åŠ ç¸£å¸‚ç•Œç·šåœ–å±¤ï¼ˆç™½è‰²é‚Šæ¡†ï¼‰
              maplibreMap.addLayer({
                id: 'county-boundaries-line',
                type: 'line',
                source: 'county-boundaries',
                paint: {
                  'line-color': '#ffffff',
                  'line-width': 2,
                  'line-opacity': 0.8,
                },
              });
              console.log('[MapTab] MapLibre GL 3D - ç¸£å¸‚ç•Œç·šç¹ªè£½å®Œæˆ');
            }

            // æ·»åŠ  GeoJSON æº
            maplibreMap.addSource('hexagons-3d', {
              type: 'geojson',
              data: {
                type: 'FeatureCollection',
                features: featuresWithHeight,
              },
            });

            // æ·»åŠ å¡«å……åœ–å±¤
            maplibreMap.addLayer({
              id: 'hexagons-3d-fill',
              type: 'fill-extrusion',
              source: 'hexagons-3d',
              paint: {
                'fill-extrusion-color': ['get', 'color'],
                'fill-extrusion-height': ['get', 'base_height'],
                'fill-extrusion-base': 0,
                'fill-extrusion-opacity': 0.8,
              },
            });

            // ä¸æ·»åŠ é‚Šæ¡†åœ–å±¤ï¼ˆç§»é™¤ç™½è‰²é‚Šæ¡†ï¼‰

            // æ ¼å¼åŒ– village_list ç‚º HTML
            const formatVillageList = (villageList) => {
              if (!villageList) return 'N/A';

              // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œå˜—è©¦è§£æ
              let villages = villageList;
              if (typeof villageList === 'string') {
                try {
                  // å…ˆå˜—è©¦æ¨™æº– JSON è§£æ
                  villages = JSON.parse(villageList);
                } catch (e) {
                  try {
                    // å¦‚æœæ˜¯ Python æ ¼å¼çš„å­—ç¬¦ä¸²ï¼ˆä½¿ç”¨å–®å¼•è™Ÿï¼‰ï¼Œå…ˆè½‰æ›ç‚ºæ¨™æº– JSON
                    // å°‡å–®å¼•è™Ÿæ”¹ç‚ºé›™å¼•è™Ÿï¼ŒNone æ”¹ç‚º null
                    const jsonString = villageList
                      .replace(/'/g, '"')
                      .replace(/None/g, 'null')
                      .replace(/True/g, 'true')
                      .replace(/False/g, 'false');
                    villages = JSON.parse(jsonString);
                  } catch (e2) {
                    return villageList; // å¦‚æœè§£æå¤±æ•—ï¼Œç›´æ¥è¿”å›å­—ç¬¦ä¸²
                  }
                }
              }

              // å¦‚æœä¸æ˜¯æ•¸çµ„ï¼Œè¿”å›åŸå€¼
              if (!Array.isArray(villages)) {
                return String(villages);
              }

              // æ ¼å¼åŒ–æ¯å€‹ village é …ç›®
              if (villages.length === 0) return 'ç„¡è³‡æ–™';

              return villages
                .map((village, index) => {
                  if (typeof village === 'object' && village !== null) {
                    const items = Object.keys(village)
                      .map((key) => {
                        const val = village[key];
                        const displayVal = val === null || val === undefined ? 'N/A' : val;
                        return `<span style="margin-right: 10px;"><strong>${key}:</strong> ${displayVal}</span>`;
                      })
                      .join('');
                    return `<div style="margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 3px;">${index + 1}. ${items}</div>`;
                  }
                  return `<div style="margin: 5px 0;">${index + 1}. ${village}</div>`;
                })
                .join('');
            };

            // æ·»åŠ é»æ“Šäº‹ä»¶
            maplibreMap.on('click', 'hexagons-3d-fill', (e) => {
              const properties = e.features[0].properties;
              console.log('[MapTab] MapLibre GL - é»æ“Šçš„å¯¦é«”ä¿¡æ¯:', properties);

              // æ ¼å¼åŒ–æ‰€æœ‰å±¬æ€§ç‚º HTML
              let html = '<div style="max-width: 400px; max-height: 500px; overflow-y: auto;">';

              Object.keys(properties).forEach((key) => {
                const value = properties[key];

                if (key === 'village_list' || key === 'villageList') {
                  // ç‰¹æ®Šè™•ç† village_list
                  html += `<div style="margin-bottom: 10px;"><strong>${key}:</strong><div style="margin-top: 5px;">${formatVillageList(value)}</div></div>`;
                } else {
                  html += `<div style="margin-bottom: 5px;"><strong>${key}:</strong> ${value}</div>`;
                }
              });

              html += '</div>';

              // å‰µå»ºå½ˆå‡ºæ¡†
              new maplibregl.Popup({ maxWidth: '450px' })
                .setLngLat(e.lngLat)
                .setHTML(html)
                .addTo(maplibreMap);
            });

            // æ”¹è®Šé¼ æ¨™æ¨£å¼
            maplibreMap.on('mouseenter', 'hexagons-3d-fill', () => {
              maplibreMap.getCanvas().style.cursor = 'pointer';
            });

            maplibreMap.on('mouseleave', 'hexagons-3d-fill', () => {
              maplibreMap.getCanvas().style.cursor = '';
            });

            isMapReady.value = true;
            console.log('[MapTab] MapLibre GL 3D åœ°åœ–åˆå§‹åŒ–å®Œæˆ');
          });

          maplibreMap.on('error', (error) => {
            console.error('[MapTab] MapLibre GL åœ°åœ–è¼‰å…¥éŒ¯èª¤:', error);
          });
        } catch (error) {
          console.error('[MapTab] MapLibre GL 3D åœ°åœ–åˆå§‹åŒ–å¤±æ•—:', error);
        }
      };

      /**
       * ğŸŒ åˆå§‹åŒ– CesiumJS 3D åœ°åœ– (æ¨¡å¼2)
       */
      const initCesium3D2 = async () => {
        try {
          console.log('[MapTab] é–‹å§‹åˆå§‹åŒ– CesiumJS 3D åœ°åœ–ï¼ˆæ¨¡å¼2ï¼‰');

          if (!mapContainer.value || !hexData2.value) {
            console.error('[MapTab] ç„¡æ³•åˆå§‹åŒ– CesiumJSï¼ˆæ¨¡å¼2ï¼‰: å®¹å™¨æˆ–æ•¸æ“šä¸å­˜åœ¨');
            return;
          }

          if (!countyData.value) {
            await loadCountyData();
          }

          if (typeof window.Cesium === 'undefined') {
            console.error('[MapTab] CesiumJS å°šæœªè¼‰å…¥ï¼Œè«‹ç¢ºä¿å·²å¼•å…¥ CDN è…³æœ¬');
            return;
          }

          // eslint-disable-next-line no-undef
          const Cesium = window.Cesium;

          Cesium.Ion.defaultAccessToken =
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxYjJiZjlhZC1mZDNkLTRiZWEtYjExNy1iZDI1OWQ5ZmJlZmEiLCJpZCI6MzU1MDgxLCJpYXQiOjE3NjE3MTc5NTl9.ivNUz20WJNOvyTB6vzB8xHNWNSzgl06vBAGOuZLNKs4';

          const worldTerrain = await Cesium.createWorldTerrainAsync();

          cesiumViewer = new Cesium.Viewer(mapContainer.value, {
            terrainProvider: worldTerrain,
            baseLayerPicker: false,
            geocoder: false,
            homeButton: false,
            infoBox: true,
            sceneModePicker: false,
            selectionIndicator: false,
            timeline: false,
            animation: false,
            fullscreenButton: false,
            vrButton: false,
            navigationHelpButton: false,
          });

          cesiumViewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(121.0, 23.5, 500000),
            orientation: {
              heading: 0.0,
              pitch: -0.5,
              roll: 0.0,
            },
          });

          const calculateHexWidth = () => {
            if (
              !hexData2.value ||
              !hexData2.value.features ||
              hexData2.value.features.length === 0
            ) {
              return 6000;
            }

            const firstHex = hexData2.value.features.find(
              (f) =>
                f.geometry && f.geometry.coordinates?.[0] && f.geometry.coordinates[0].length >= 4
            );

            if (!firstHex || !firstHex.geometry.coordinates[0]) {
              return 6000;
            }

            const coords = firstHex.geometry.coordinates[0];
            const p1 = coords[0];
            const p4 = coords[3];

            const R = 6371000;
            const lat1 = (p1[1] * Math.PI) / 180;
            const lat4 = (p4[1] * Math.PI) / 180;
            const dLat = ((p4[1] - p1[1]) * Math.PI) / 180;
            const dLon = ((p4[0] - p1[0]) * Math.PI) / 180;
            const a =
              Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1) * Math.cos(lat4) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const width = R * c;

            console.log('[MapTab] CesiumJS 3Dï¼ˆæ¨¡å¼2ï¼‰- è¨ˆç®—çš„å…­è§’å½¢å¯¬åº¦ï¼ˆç±³ï¼‰:', width);
            return width;
          };

          const hexWidth = calculateHexWidth();

          const valueKey = 'æœ‰å¶_ç›¸åŒæ€§åˆ¥_ç¸½è¨ˆ';
          const getValue = (feature) => Number(feature?.properties?.[valueKey]) || 0;

          const { min, max } = hexData2Stats.value || {};
          const domainMin = Number.isFinite(min) && min > 0 ? min : 0;
          const rawMax = Number.isFinite(max) && max > 0 ? max : domainMin;
          const effectiveMax = rawMax > domainMin ? rawMax : domainMin === 0 ? 1 : domainMin * 1.01;

          const heightScale = d3
            .scaleLinear()
            .domain([domainMin, effectiveMax])
            .range([hexWidth * 0.5, hexWidth * 8]);

          const colorScale = createPrideGradientScale(domainMin, effectiveMax);

          const features = Array.isArray(hexData2.value.features) ? hexData2.value.features : [];
          const validFeatures = features.filter(
            (feature) =>
              feature.geometry && feature.geometry.type === 'Polygon' && getValue(feature) > 0
          );

          if (countyData.value && countyData.value.features) {
            countyData.value.features.forEach((countyFeature) => {
              if (countyFeature.geometry && countyFeature.geometry.type === 'Polygon') {
                const coordinates = countyFeature.geometry.coordinates[0];
                const positions = coordinates.map((coord) =>
                  Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 0)
                );

                cesiumViewer.entities.add({
                  polyline: {
                    positions: positions.concat([positions[0]]),
                    width: 2.0,
                    material: Cesium.Color.WHITE.withAlpha(0.8),
                    clampToGround: true,
                  },
                });
              } else if (countyFeature.geometry && countyFeature.geometry.type === 'MultiPolygon') {
                countyFeature.geometry.coordinates.forEach((polygon) => {
                  const coordinates = polygon[0];
                  const positions = coordinates.map((coord) =>
                    Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 0)
                  );

                  cesiumViewer.entities.add({
                    polyline: {
                      positions: positions.concat([positions[0]]),
                      width: 2.0,
                      material: Cesium.Color.WHITE.withAlpha(0.8),
                      clampToGround: true,
                    },
                  });
                });
              }
            });
          }

          validFeatures.forEach((feature) => {
            const value = getValue(feature);
            const color = Cesium.Color.fromCssColorString(
              colorScale(Math.min(effectiveMax, Math.max(domainMin, value)))
            ).withAlpha(1);
            const coordinates = feature.geometry.coordinates[0];
            const extrudedHeight = heightScale(Math.min(effectiveMax, Math.max(domainMin, value)));
            const hierarchy = coordinates.map((coord) =>
              Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 0)
            );

            cesiumViewer.entities.add({
              polygon: {
                hierarchy,
                material: color,
                height: 0,
                extrudedHeight,
                outline: false,
              },
              properties: feature.properties,
            });
          });

          const formatVillageList = (villageList) => {
            if (!villageList) return 'N/A';
            let villages = villageList;
            if (typeof villageList === 'string') {
              try {
                villages = JSON.parse(villageList);
              } catch (e) {
                try {
                  const jsonString = villageList
                    .replace(/'/g, '"')
                    .replace(/None/g, 'null')
                    .replace(/True/g, 'true')
                    .replace(/False/g, 'false');
                  villages = JSON.parse(jsonString);
                } catch (e2) {
                  return villageList;
                }
              }
            }

            if (!Array.isArray(villages)) {
              return String(villages);
            }

            if (villages.length === 0) return 'ç„¡è³‡æ–™';

            return villages
              .map((village, index) => {
                if (typeof village === 'object' && village !== null) {
                  const items = Object.keys(village)
                    .map((key) => {
                      const val = village[key];
                      const displayVal = val === null || val === undefined ? 'N/A' : val;
                      return `${key}: ${displayVal}`;
                    })
                    .join(', ');
                  return `${index + 1}. ${items}`;
                }
                return `${index + 1}. ${village}`;
              })
              .join('<br>');
          };

          const handler = new Cesium.ScreenSpaceEventHandler(cesiumViewer.scene.canvas);
          handler.setInputAction((click) => {
            const pickedObject = cesiumViewer.scene.pick(click.position);
            if (Cesium.defined(pickedObject) && pickedObject.id && pickedObject.id.properties) {
              const properties = pickedObject.id.properties;
              let html = '<div style="max-width: 420px; max-height: 520px; overflow-y: auto;">';

              for (const key in properties) {
                if (Object.prototype.hasOwnProperty.call(properties, key)) {
                  const propertyValue = properties[key];
                  const value =
                    propertyValue &&
                    typeof propertyValue === 'object' &&
                    typeof propertyValue.getValue === 'function'
                      ? propertyValue.getValue()
                      : propertyValue;

                  if (key === 'village_list' || key === 'villageList') {
                    html += `<div><strong>${key}:</strong><br>${formatVillageList(value)}</div><br>`;
                  } else {
                    html += `<div><strong>${key}:</strong> ${value}</div>`;
                  }
                }
              }

              html += '</div>';

              if (cesiumViewer.infoBox && pickedObject.id) {
                cesiumViewer.selectedEntity = pickedObject.id;
                cesiumViewer.infoBox.viewModel.description = html;
              }
            }
          }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

          isMapReady.value = true;
          console.log('[MapTab] CesiumJS 3D åœ°åœ–ï¼ˆæ¨¡å¼2ï¼‰åˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
          console.error('[MapTab] CesiumJS 3D åœ°åœ–ï¼ˆæ¨¡å¼2ï¼‰åˆå§‹åŒ–å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ—ºï¸ åˆå§‹åŒ– MapLibre GL 3D åœ°åœ– (æ¨¡å¼2)
       */
      const initMapLibre3D2 = async () => {
        try {
          console.log('[MapTab] é–‹å§‹åˆå§‹åŒ– MapLibre GL 3D åœ°åœ–ï¼ˆæ¨¡å¼2ï¼‰');

          if (!mapContainer.value || !hexData2.value) {
            console.error('[MapTab] ç„¡æ³•åˆå§‹åŒ– MapLibre GLï¼ˆæ¨¡å¼2ï¼‰: å®¹å™¨æˆ–æ•¸æ“šä¸å­˜åœ¨');
            return;
          }

          if (!countyData.value) {
            await loadCountyData();
          }

          maplibreMap = new maplibregl.Map({
            container: mapContainer.value,
            style: {
              version: 8,
              sources: {
                carto: {
                  type: 'raster',
                  tiles: [
                    'https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                    'https://b.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                    'https://c.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                  ],
                  tileSize: 256,
                  attribution:
                    '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                },
              },
              layers: [
                {
                  id: 'carto-dark-layer',
                  type: 'raster',
                  source: 'carto',
                  minzoom: 0,
                  maxzoom: 22,
                },
              ],
            },
            center: [121.0, 23.5],
            zoom: 8,
            pitch: 45,
            bearing: 0,
            antialias: true,
          });

          maplibreMap.on('load', () => {
            console.log('[MapTab] MapLibre GL åœ°åœ–ï¼ˆæ¨¡å¼2ï¼‰è¼‰å…¥å®Œæˆ');

            const calculateHexWidth = () => {
              if (
                !hexData2.value ||
                !hexData2.value.features ||
                hexData2.value.features.length === 0
              ) {
                return 6000;
              }

              const firstHex = hexData2.value.features.find(
                (f) =>
                  f.geometry && f.geometry.coordinates?.[0] && f.geometry.coordinates[0].length >= 4
              );

              if (!firstHex || !firstHex.geometry.coordinates[0]) {
                return 6000;
              }

              const coords = firstHex.geometry.coordinates[0];
              const p1 = coords[0];
              const p4 = coords[3];

              const R = 6371000;
              const lat1 = (p1[1] * Math.PI) / 180;
              const lat4 = (p4[1] * Math.PI) / 180;
              const dLat = ((p4[1] - p1[1]) * Math.PI) / 180;
              const dLon = ((p4[0] - p1[0]) * Math.PI) / 180;
              const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1) * Math.cos(lat4) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
              const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
              const width = R * c;

              console.log('[MapTab] MapLibre GL 3Dï¼ˆæ¨¡å¼2ï¼‰- è¨ˆç®—çš„å…­è§’å½¢å¯¬åº¦ï¼ˆç±³ï¼‰:', width);
              return width;
            };

            const hexWidth = calculateHexWidth();

            const valueKey = 'æœ‰å¶_ç›¸åŒæ€§åˆ¥_ç¸½è¨ˆ';
            const getValue = (feature) => Number(feature?.properties?.[valueKey]) || 0;

            const { min, max } = hexData2Stats.value || {};
            const domainMin = Number.isFinite(min) && min > 0 ? min : 0;
            const rawMax = Number.isFinite(max) && max > 0 ? max : domainMin;
            const effectiveMax =
              rawMax > domainMin ? rawMax : domainMin === 0 ? 1 : domainMin * 1.01;

            const heightScale = d3
              .scaleLinear()
              .domain([domainMin, effectiveMax])
              .range([hexWidth * 0.5, hexWidth * 8]);

            const colorScale = createPrideGradientScale(domainMin, effectiveMax);

            const features = Array.isArray(hexData2.value.features) ? hexData2.value.features : [];
            const featuresWithHeight = features
              .filter(
                (feature) =>
                  feature.geometry && feature.geometry.type === 'Polygon' && getValue(feature) > 0
              )
              .map((feature) => {
                const value = getValue(feature);
                return {
                  ...feature,
                  properties: {
                    ...feature.properties,
                    base_height: heightScale(Math.min(effectiveMax, Math.max(domainMin, value))),
                    color: colorScale(Math.min(effectiveMax, Math.max(domainMin, value))),
                  },
                };
              });

            if (countyData.value && countyData.value.features) {
              maplibreMap.addSource('county-boundaries', {
                type: 'geojson',
                data: countyData.value,
              });

              maplibreMap.addLayer({
                id: 'county-boundaries-line',
                type: 'line',
                source: 'county-boundaries',
                paint: {
                  'line-color': '#ffffff',
                  'line-width': 2,
                  'line-opacity': 0.8,
                },
              });
              console.log('[MapTab] MapLibre GL 3Dï¼ˆæ¨¡å¼2ï¼‰- ç¸£å¸‚ç•Œç·šç¹ªè£½å®Œæˆ');
            }

            maplibreMap.addSource('hexagons-3d', {
              type: 'geojson',
              data: {
                type: 'FeatureCollection',
                features: featuresWithHeight,
              },
            });

            maplibreMap.addLayer({
              id: 'hexagons-3d-fill',
              type: 'fill-extrusion',
              source: 'hexagons-3d',
              paint: {
                'fill-extrusion-color': ['get', 'color'],
                'fill-extrusion-height': ['get', 'base_height'],
                'fill-extrusion-base': 0,
                'fill-extrusion-opacity': 1,
              },
            });

            const formatVillageList = (villageList) => {
              if (!villageList) return 'N/A';
              let villages = villageList;
              if (typeof villageList === 'string') {
                try {
                  villages = JSON.parse(villageList);
                } catch (e) {
                  try {
                    const jsonString = villageList
                      .replace(/'/g, '"')
                      .replace(/None/g, 'null')
                      .replace(/True/g, 'true')
                      .replace(/False/g, 'false');
                    villages = JSON.parse(jsonString);
                  } catch (e2) {
                    return villageList;
                  }
                }
              }

              if (!Array.isArray(villages)) {
                return String(villages);
              }

              if (villages.length === 0) return 'ç„¡è³‡æ–™';

              return villages
                .map((village, index) => {
                  if (typeof village === 'object' && village !== null) {
                    const items = Object.keys(village)
                      .map((key) => {
                        const val = village[key];
                        const displayVal = val === null || val === undefined ? 'N/A' : val;
                        return `<span style="margin-right: 10px;"><strong>${key}:</strong> ${displayVal}</span>`;
                      })
                      .join('');
                    return `<div style="margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 3px;">${index + 1}. ${items}</div>`;
                  }
                  return `<div style="margin: 5px 0;">${index + 1}. ${village}</div>`;
                })
                .join('');
            };

            maplibreMap.on('click', 'hexagons-3d-fill', (e) => {
              const properties = e.features[0].properties;
              console.log('[MapTab] MapLibre GLï¼ˆæ¨¡å¼2ï¼‰- é»æ“Šçš„å¯¦é«”ä¿¡æ¯:', properties);

              let html = '<div style="max-width: 420px; max-height: 520px; overflow-y: auto;">';

              Object.keys(properties).forEach((key) => {
                const value = properties[key];

                if (key === 'village_list' || key === 'villageList') {
                  html += `<div style="margin-bottom: 10px;"><strong>${key}:</strong><div style="margin-top: 5px;">${formatVillageList(value)}</div></div>`;
                } else {
                  html += `<div style="margin-bottom: 5px;"><strong>${key}:</strong> ${value}</div>`;
                }
              });

              html += '</div>';

              new maplibregl.Popup({ maxWidth: '450px' })
                .setLngLat(e.lngLat)
                .setHTML(html)
                .addTo(maplibreMap);
            });

            maplibreMap.on('mouseenter', 'hexagons-3d-fill', () => {
              maplibreMap.getCanvas().style.cursor = 'pointer';
            });

            maplibreMap.on('mouseleave', 'hexagons-3d-fill', () => {
              maplibreMap.getCanvas().style.cursor = '';
            });

            isMapReady.value = true;
            console.log('[MapTab] MapLibre GL 3D åœ°åœ–ï¼ˆæ¨¡å¼2ï¼‰åˆå§‹åŒ–å®Œæˆ');
          });

          maplibreMap.on('error', (error) => {
            console.error('[MapTab] MapLibre GL åœ°åœ–ï¼ˆæ¨¡å¼2ï¼‰è¼‰å…¥éŒ¯èª¤:', error);
          });
        } catch (error) {
          console.error('[MapTab] MapLibre GL 3D åœ°åœ–ï¼ˆæ¨¡å¼2ï¼‰åˆå§‹åŒ–å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ—ºï¸ ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆä½¿ç”¨ ratio_China æ•¸æ“šï¼‰
       */
      const drawHexGrid = () => {
        if (!g || !hexData.value || !path) {
          console.error(
            '[MapTab] ç„¡æ³•ç¹ªè£½å…­è§’å½¢ç¶²æ ¼: g=',
            !!g,
            'hexData=',
            !!hexData.value,
            'path=',
            !!path
          );
          return;
        }

        try {
          console.log('[MapTab] é–‹å§‹ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ GeoJSON');

          // å…ˆæ¸…é™¤èˆŠçš„åœ–å±¤
          g.selectAll('.hex-grid').remove();

          // éæ¿¾æ‰äººå£æ•¸ç‚º0æˆ–ratio_Chinaç‚º0æˆ–æ²’æœ‰levelçš„å€åŸŸ
          const validFeatures = hexData.value.features.filter(
            (d) =>
              d.properties['äººå£æ•¸'] &&
              d.properties['äººå£æ•¸'] > 0 &&
              d.properties['ratio_China'] &&
              d.properties['ratio_China'] > 0 &&
              d.properties['level'] &&
              d.properties['level'] >= 1 &&
              d.properties['level'] <= 5
          );

          console.log('[MapTab] ä½¿ç”¨ level åˆ†é¡æ•¸æ“š:', {
            total: hexData.value.features.length,
            valid: validFeatures.length, // äººå£æ•¸ > 0 ä¸” ratio_China > 0 ä¸”æœ‰ level
          });

          // é¡è‰²æ–¹æ¡ˆï¼š5ç´šï¼ŒåŸºæ–¼ä¸­åœ‹åœ‹æ——ç´…è‰² #DE2910 çš„æ¼¸è®Šï¼ˆæ·ºâ†’æ·±ï¼‰
          const colors = [
            '#f9d5d3', // level 1 - å¾ˆæ·ºï¼ˆä¸­åœ‹ç´…çš„æ·¡åŒ–ç‰ˆï¼‰
            '#f4a9a3', // level 2 - æ·º
            '#ee6c5e', // level 3 - ä¸­
            '#de2910', // level 4 - ä¸­åœ‹åœ‹æ——ç´…
            '#a51f0c', // level 5 - æ·±ï¼ˆä¸­åœ‹ç´…çš„æ·±åŒ–ç‰ˆï¼‰
          ];

          // é¡è‰²æ˜ å°„å‡½æ•¸ï¼šç›´æ¥æ ¹æ“š level (1-5) è¿”å›é¡è‰²
          const getColor = (level) => {
            if (!level || level < 1 || level > 5) return '#f0f0f0'; // ç„¡æ•¸æ“šçš„é¡è‰²
            return colors[level - 1]; // level 1-5 å°æ‡‰ colors[0-4]
          };

          // è¨ˆç®—å„ç´šæ•¸é‡ï¼ˆæ ¹æ“š level çµ±è¨ˆï¼‰
          const classCounts = new Array(colors.length).fill(0);
          validFeatures.forEach((d) => {
            const level = d.properties['level'];
            if (level >= 1 && level <= 5) {
              classCounts[level - 1]++; // level 1-5 å°æ‡‰ classCounts[0-4]
            }
          });

          // æŒ‰ level æ’åºï¼ˆåªè€ƒæ…®äººå£æ•¸ > 0 ä¸” ratio_China > 0 ä¸”æœ‰ level çš„å€åŸŸï¼‰
          const sortedHexes = validFeatures.sort((a, b) => {
            const levelA = a.properties['level'] || 0;
            const levelB = b.properties['level'] || 0;
            return levelA - levelB;
          });

          console.log('[DEBUG] ç¸½å…±è¦ç¹ªè£½çš„å…­è§’å½¢ç¶²æ ¼æ•¸:', sortedHexes.length);
          console.log(
            '[DEBUG] å‰ 5 å€‹ç¶²æ ¼:',
            sortedHexes.slice(0, 5).map((d) => ({
              level: d.properties['level'],
              ratio_China: d.properties['ratio_China'],
              color: getColor(d.properties['level']),
            }))
          );

          // Map æ¨¡å¼ï¼šä½¿ç”¨åœ°åœ–æŠ•å½±ç¹ªè£½ï¼ˆä½¿ç”¨ GeoJSON coordinatesï¼‰
          console.log('[MapTab] ä½¿ç”¨ Map æ¨¡å¼ç¹ªè£½ï¼ˆåœ°åœ–æŠ•å½±ï¼‰');
          console.log('[MapTab] path generator:', !!path, 'g:', !!g);

          // ç¹ªè£½æ‰€æœ‰å…­è§’å½¢ç¶²æ ¼
          const hexPaths = g
            .selectAll('.hex-grid')
            .data(sortedHexes)
            .enter()
            .append('path')
            .attr('d', path)
            .attr('class', 'hex-grid')
            .attr('fill', (d) => getColor(d.properties['level']))
            .attr('fill-opacity', 0.8)
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 0.5)
            .style('cursor', 'pointer');

          console.log('[DEBUG] ç¹ªè£½äº†å¤šå°‘å€‹ path å…ƒç´ :', hexPaths.size());

          hexPaths
            .on('mouseover', function (event, d) {
              d3.select(this).attr('fill-opacity', 1).attr('stroke-width', 2);
              if (tooltip) {
                const properties = d.properties;
                // æ ¼å¼åŒ–å°æ•¸å€¼ç‚ºæ˜“è®€æ ¼å¼
                const formatValue = (key, value) => {
                  if (value === null || value === undefined) return 'N/A';
                  // å°æ–¼ ratio é–‹é ­çš„æ¬„ä½ï¼Œæ ¼å¼åŒ–ç‚ºå°æ•¸
                  if (key.startsWith('ratio_') && typeof value === 'number') {
                    if (value === 0) return '0';
                    if (value < 0.0001) {
                      return value.toExponential(2);
                    }
                    if (value < 0.01) {
                      return value.toFixed(5);
                    }
                    return value.toFixed(4);
                  }
                  return value;
                };
                // é¡¯ç¤ºæ‰€æœ‰ properties æ¬„ä½
                let tooltipHTML = '';
                Object.keys(properties).forEach((key) => {
                  const value = properties[key];
                  tooltipHTML += `<div><strong>${key}:</strong> ${formatValue(key, value)}</div>`;
                });
                tooltip.innerHTML = tooltipHTML;
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
                tooltip.style.opacity = 1;
              }
            })
            .on('mousemove', function (event) {
              if (tooltip) {
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
              }
            })
            .on('mouseout', function () {
              d3.select(this).attr('fill-opacity', 0.8).attr('stroke-width', 0.5);
              if (tooltip) {
                tooltip.style.opacity = 0;
              }
            });

          // ç¹ªè£½åœ–ä¾‹
          drawLegend(colors, classCounts);

          console.log('[MapTab] å…­è§’å½¢ç¶²æ ¼ï¼ˆåœ°åœ–æ¨¡å¼ï¼‰ç¹ªè£½å®Œæˆ');
          console.log('  - ä½¿ç”¨ level åˆ†é¡ (1-5)');
          console.log('  - SVG ä¸­çš„ path å…ƒç´ æ•¸é‡:', g.selectAll('path').size());
          console.log('  - hex-grid class å…ƒç´ æ•¸é‡:', g.selectAll('.hex-grid').size());
        } catch (error) {
          console.error('[MapTab] ç™»é©ç†±ç¶²æ ¼ç¹ªè£½å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ¨ ç¹ªè£½åœ–ä¾‹
       */
      const drawLegend = (colors, classCounts) => {
        if (!svg || !mapContainer.value) return;

        // ç§»é™¤èˆŠçš„åœ–ä¾‹
        svg.selectAll('.legend').remove();

        // åœ–ä¾‹å°ºå¯¸ï¼ˆå¢åŠ å¯¬åº¦å’Œé«˜åº¦ä»¥æ”¹å–„é–“è·ï¼‰
        const legendWidth = 280;
        const legendHeight = 24;
        const padding = 15;
        const labelSpacing = 28; // æ¨™ç±¤ä¹‹é–“çš„å‚ç›´é–“è·

        // è¨ˆç®—å³ä¸‹è§’ä½ç½®ï¼ˆä½¿ç”¨å®¹å™¨å¯¦éš›å°ºå¯¸ï¼‰
        const rect = mapContainer.value.getBoundingClientRect();
        const svgWidth = rect.width;
        const svgHeight = rect.height;
        const legendX = svgWidth - legendWidth - padding;
        const legendY = svgHeight - legendHeight - 120; // ç•™å‡ºæ›´å¤šæ¨™ç±¤ç©ºé–“

        // å‰µå»ºåœ–ä¾‹çµ„ï¼ˆå›ºå®šåœ¨ viewportï¼Œä¸å— zoom å½±éŸ¿ï¼‰
        const legend = svg
          .append('g')
          .attr('class', 'legend')
          .attr('data-legend-x', legendX)
          .attr('data-legend-y', legendY)
          .attr('transform', `translate(${legendX}, ${legendY})`);

        // ç¹ªè£½æ¯å€‹é¡è‰²å¡Š
        legend
          .selectAll('.legend-color')
          .data(colors)
          .enter()
          .append('rect')
          .attr('class', 'legend-color')
          .attr('x', (d, i) => i * (legendWidth / colors.length))
          .attr('y', 0)
          .attr('width', legendWidth / colors.length)
          .attr('height', legendHeight)
          .attr('fill', (d) => d)
          .attr('stroke', '#333')
          .attr('stroke-width', 1);

        // æ·»åŠ  level æ¨™ç±¤ (1-5)
        const levels = [1, 2, 3, 4, 5];
        legend
          .selectAll('.legend-label')
          .data(levels)
          .enter()
          .append('text')
          .attr('class', 'legend-label')
          .attr('x', (d, i) => (i + 0.5) * (legendWidth / levels.length))
          .attr('y', legendHeight + labelSpacing)
          .attr('font-size', '12px')
          .attr('fill', '#333')
          .attr('text-anchor', 'middle')
          .text((d) => `Level ${d}`);

        // æ·»åŠ å„ç´šæ•¸é‡æ¨™ç±¤
        if (classCounts) {
          legend
            .selectAll('.legend-count')
            .data(classCounts)
            .enter()
            .append('text')
            .attr('class', 'legend-count')
            .attr('x', (d, i) => (i + 0.5) * (legendWidth / classCounts.length))
            .attr('y', legendHeight + labelSpacing * 2)
            .attr('font-size', '11px')
            .attr('fill', '#666')
            .attr('text-anchor', 'middle')
            .text((d) => d);
        }

        // æ·»åŠ æ¨™é¡Œ
        legend
          .append('text')
          .attr('class', 'legend-title')
          .attr('x', legendWidth / 2)
          .attr('y', -12)
          .attr('font-size', '13px')
          .attr('font-weight', 'bold')
          .attr('fill', '#333')
          .attr('text-anchor', 'middle')
          .text('ratio_China (æ¯”ä¾‹å€¼) - Level');
      };

      /**
       * ğŸŒˆ Pride å…­è‰²åœ–ä¾‹
       */
      const drawPrideGradientLegend = (min, max, colorScale) => {
        if (!svg || !mapContainer.value) return;

        svg.selectAll('.legend').remove();

        const rect = mapContainer.value.getBoundingClientRect();
        const svgWidth = rect.width;
        const svgHeight = rect.height;
        const legendWidth = 260;
        const boxHeight = 16;
        const legendX = svgWidth - legendWidth - 15;
        const legendY = svgHeight - boxHeight - 120;

        const legend = svg
          .append('g')
          .attr('class', 'legend')
          .attr('transform', `translate(${legendX}, ${legendY})`);

        legend
          .append('text')
          .attr('x', legendWidth / 2)
          .attr('y', -10)
          .attr('text-anchor', 'middle')
          .attr('font-size', '13px')
          .attr('font-weight', 'bold')
          .attr('fill', '#f5f5f5')
          .text('æœ‰å¶_ç›¸åŒæ€§åˆ¥_ç¸½è¨ˆ');

        let start = Number.isFinite(min) ? min : 0;
        let end = Number.isFinite(max) ? max : start;
        if (end <= start) {
          end = start === 0 ? 1 : start + Math.abs(start) * 0.01;
        }

        let defs = svg.select('defs');
        if (defs.empty()) {
          defs = svg.append('defs');
        }

        defs.select('#pride-gradient').remove();
        const gradient = defs
          .append('linearGradient')
          .attr('id', 'pride-gradient')
          .attr('x1', '0%')
          .attr('y1', '0%')
          .attr('x2', '100%')
          .attr('y2', '0%');

        prideColors.forEach((_, index) => {
          const t = index / (prideColors.length - 1);
          const value = start + t * (end - start);
          gradient
            .append('stop')
            .attr('offset', `${t * 100}%`)
            .attr('stop-color', colorScale(value));
        });

        legend
          .append('rect')
          .attr('width', legendWidth)
          .attr('height', boxHeight)
          .attr('fill', 'url(#pride-gradient)')
          .attr('stroke', '#f5f5f5')
          .attr('stroke-width', 1)
          .attr('rx', 4)
          .attr('ry', 4);

        const scale = d3.scaleLinear().domain([start, end]).range([0, legendWidth]);
        const axis = d3
          .axisBottom(scale)
          .ticks(6)
          .tickFormat((d) => Math.round(d).toLocaleString());

        legend
          .append('g')
          .attr('transform', `translate(0, ${boxHeight})`)
          .call(axis)
          .selectAll('text')
          .style('font-size', '11px')
          .style('fill', '#f5f5f5');

        legend.selectAll('.domain, .tick line').style('stroke', '#f5f5f5');
      };

      /**
       * ğŸ—ºï¸ Pride å…­è‰²åœ°åœ–ï¼ˆæ¨¡å¼2ï¼‰
       */
      const drawHexGrid2 = () => {
        if (!g || !hexData2.value || !path) {
          console.error(
            '[MapTab] ç„¡æ³•ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆæ¨¡å¼2ï¼‰: g=',
            !!g,
            'hexData2=',
            !!hexData2.value,
            'path=',
            !!path
          );
          return;
        }

        try {
          console.log('[MapTab] é–‹å§‹ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆæ¨¡å¼2ï¼‰GeoJSON');

          g.selectAll('.hex-grid').remove();

          const features = Array.isArray(hexData2.value.features) ? hexData2.value.features : [];
          const valueKey = 'æœ‰å¶_ç›¸åŒæ€§åˆ¥_ç¸½è¨ˆ';
          const getValue = (feature) => Number(feature?.properties?.[valueKey]) || 0;

          const { min, max } = hexData2Stats.value || {};
          const domainMin = Number.isFinite(min) && min > 0 ? min : 0;
          const domainMax = Number.isFinite(max) && max > 0 ? max : domainMin > 0 ? domainMin : 1;
          const colorScale = createPrideGradientScale(domainMin, domainMax);

          const validFeatures = features.filter((feature) => getValue(feature) > 0);

          if (validFeatures.length === 0) {
            console.warn('[MapTab] æ¨¡å¼2 ç„¡å¯ç”¨çš„ Pride å…­è§’æ ¼');
            g.selectAll('.legend').remove();
            return;
          }

          const sortedHexes = [...validFeatures].sort((a, b) => getValue(a) - getValue(b));

          console.log('[DEBUG] æ¨¡å¼2 - æœ‰æ•ˆå…­è§’æ ¼æ•¸é‡:', sortedHexes.length);
          console.log('[DEBUG] æ¨¡å¼2 - æ•¸å€¼ç¯„åœ:', { min: domainMin, max: domainMax });

          const hexPaths = g
            .selectAll('.hex-grid')
            .data(sortedHexes)
            .enter()
            .append('path')
            .attr('d', path)
            .attr('class', 'hex-grid')
            .attr('fill', (d) => colorScale(Math.min(domainMax, Math.max(domainMin, getValue(d)))))
            .attr('fill-opacity', 0.85)
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 0.5)
            .style('cursor', 'pointer');

          hexPaths
            .on('mouseover', function (event, d) {
              d3.select(this).attr('fill-opacity', 1).attr('stroke-width', 2);
              if (tooltip) {
                const properties = d.properties || {};
                const formatValue = (key, value) => {
                  if (value === null || value === undefined) return 'N/A';
                  if (typeof value === 'number') {
                    return value.toLocaleString();
                  }
                  return value;
                };
                let tooltipHTML = '';
                Object.keys(properties).forEach((key) => {
                  const value = properties[key];
                  tooltipHTML += `<div><strong>${key}:</strong> ${formatValue(key, value)}</div>`;
                });
                tooltip.innerHTML = tooltipHTML;
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
                tooltip.style.opacity = 1;
              }
            })
            .on('mousemove', function (event) {
              if (tooltip) {
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
              }
            })
            .on('mouseout', function () {
              d3.select(this).attr('fill-opacity', 0.85).attr('stroke-width', 0.5);
              if (tooltip) {
                tooltip.style.opacity = 0;
              }
            });

          drawPrideGradientLegend(domainMin, domainMax, colorScale);

          console.log('[MapTab] å…­è§’å½¢ç¶²æ ¼ï¼ˆæ¨¡å¼2ï¼‰ç¹ªè£½å®Œæˆ');
        } catch (error) {
          console.error('[MapTab] å…­è§’å½¢ç¶²æ ¼ï¼ˆæ¨¡å¼2ï¼‰ç¹ªè£½å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ—ºï¸ Pride å…­è‰²ç¶²æ ¼ï¼ˆGrid æ¨¡å¼2ï¼‰
       */
      const drawHexGridOnly2 = () => {
        if (!g || !hexData2.value || !path) {
          console.error(
            '[MapTab] ç„¡æ³•ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆæ¨¡å¼2ï¼‰: g=',
            !!g,
            'hexData2=',
            !!hexData2.value,
            'path=',
            !!path
          );
          return;
        }

        try {
          console.log('[MapTab] é–‹å§‹ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆGrid æ¨¡å¼2ï¼‰');

          g.selectAll('.hex-grid').remove();
          g.selectAll('.county').remove();

          const features = Array.isArray(hexData2.value.features) ? hexData2.value.features : [];
          const valueKey = 'æœ‰å¶_ç›¸åŒæ€§åˆ¥_ç¸½è¨ˆ';
          const getValue = (feature) => Number(feature?.properties?.[valueKey]) || 0;

          const { min, max } = hexData2Stats.value || {};
          const domainMin = Number.isFinite(min) && min > 0 ? min : 0;
          const domainMax = Number.isFinite(max) && max > 0 ? max : domainMin > 0 ? domainMin : 1;
          const colorScale = createPrideGradientScale(domainMin, domainMax);

          const validFeatures = features.filter((feature) => getValue(feature) > 0);

          if (validFeatures.length === 0) {
            console.warn('[MapTab] Grid æ¨¡å¼2 ç„¡å¯ç”¨çš„ Pride å…­è§’æ ¼');
            g.selectAll('.legend').remove();
            return;
          }

          const sortedHexes = [...validFeatures].sort((a, b) => getValue(a) - getValue(b));

          console.log('[DEBUG] Grid æ¨¡å¼2 - æœ‰æ•ˆå…­è§’æ ¼æ•¸é‡:', sortedHexes.length);
          console.log('[DEBUG] Grid æ¨¡å¼2 - æ•¸å€¼ç¯„åœ:', { min: domainMin, max: domainMax });

          const hexPaths = g
            .selectAll('.hex-grid')
            .data(sortedHexes)
            .enter()
            .append('path')
            .attr('d', path)
            .attr('class', 'hex-grid')
            .attr('fill', (d) => colorScale(Math.min(domainMax, Math.max(domainMin, getValue(d)))))
            .attr('fill-opacity', 0.85)
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 0.5)
            .style('cursor', 'pointer');

          hexPaths
            .on('mouseover', function (event, d) {
              d3.select(this).attr('fill-opacity', 1).attr('stroke-width', 2);
              if (tooltip) {
                const properties = d.properties || {};
                const formatValue = (key, value) => {
                  if (value === null || value === undefined) return 'N/A';
                  if (typeof value === 'number') {
                    return value.toLocaleString();
                  }
                  return value;
                };
                let tooltipHTML = '';
                Object.keys(properties).forEach((key) => {
                  const value = properties[key];
                  tooltipHTML += `<div><strong>${key}:</strong> ${formatValue(key, value)}</div>`;
                });
                tooltip.innerHTML = tooltipHTML;
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
                tooltip.style.opacity = 1;
              }
            })
            .on('mousemove', function (event) {
              if (tooltip) {
                const [mouseX, mouseY] = d3.pointer(event, mapContainer.value);
                tooltip.style.left = mouseX + 10 + 'px';
                tooltip.style.top = mouseY - 10 + 'px';
              }
            })
            .on('mouseout', function () {
              d3.select(this).attr('fill-opacity', 0.85).attr('stroke-width', 0.5);
              if (tooltip) {
                tooltip.style.opacity = 0;
              }
            });

          drawPrideGradientLegend(domainMin, domainMax, colorScale);

          console.log('[MapTab] å…­è§’å½¢ç¶²æ ¼ï¼ˆGrid æ¨¡å¼2ï¼‰ç¹ªè£½å®Œæˆ');
        } catch (error) {
          console.error('[MapTab] å…­è§’å½¢ç¶²æ ¼ï¼ˆGrid æ¨¡å¼2ï¼‰ç¹ªè£½å¤±æ•—:', error);
        }
      };

      /**
       * ğŸ—ï¸ å‰µå»ºåœ°åœ–å¯¦ä¾‹
       * åˆå§‹åŒ– D3.js åœ°åœ–ä¸¦è¨­å®šåŸºæœ¬é…ç½®
       */
      const createMap = () => {
        if (!mapContainer.value) return false;

        const rect = mapContainer.value.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          console.warn('[MapTab] å®¹å™¨å°ºå¯¸ç‚ºé›¶ï¼Œå»¶é²åˆå§‹åŒ–');
          return false;
        }

        try {
          const width = rect.width;
          const height = rect.height;

          // å°ç£ä¸­å¿ƒä½ç½®ï¼šç·¯åº¦ 23.5Â°, ç¶“åº¦ 121Â°

          // å‰µå»º SVG å…ƒç´ 
          svg = d3
            .select(mapContainer.value)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('background', '#ffffff'); // ç™½è‰²èƒŒæ™¯

          // å‰µå»ºæŠ•å½± - éº¥å¡æ‰˜æŠ•å½±ï¼Œèšç„¦åœ¨å°ç£
          projection = d3
            .geoMercator()
            .center([121, 23.5]) // ä¸­å¿ƒé»åœ¨å°ç£
            .scale(12000) // æ›´å¤§çš„ç¸®æ”¾æ¯”ä¾‹ï¼Œæ›´èšç„¦åœ¨å°ç£
            .translate([width / 2, height / 2]);

          // å‰µå»ºè·¯å¾‘ç”Ÿæˆå™¨
          path = d3.geoPath().projection(projection);

          // å‰µå»ºå®¹å™¨çµ„
          g = svg.append('g');

          // è¨­ç½®ç¸®æ”¾è¡Œç‚º
          zoom = d3
            .zoom()
            .scaleExtent([0.5, 50]) // å…è¨±ç¸®æ”¾ 0.5x åˆ° 50x
            .on('zoom', (event) => {
              if (g && g.node() && g.node().parentNode) {
                g.attr('transform', event.transform);
              }
            });

          svg.call(zoom);

          // é‡ç½®ç¸®æ”¾ç‹€æ…‹ï¼Œç¢ºä¿åˆ‡æ›æ¨¡å¼æ™‚ä¸æœƒå—åˆ°ä¹‹å‰æ¨¡å¼çš„å½±éŸ¿
          svg.call(zoom.transform, d3.zoomIdentity);

          // å‰µå»ºå·¥å…·æç¤ºå…ƒç´ 
          createTooltip();

          isMapReady.value = true;

          // å°‡åœ°åœ–å¯¦ä¾‹å‚³éçµ¦çˆ¶çµ„ä»¶
          emit('map-ready', { svg, projection, path });

          console.log('[MapTab] D3.js åœ°åœ–å‰µå»ºæˆåŠŸ');
          return true;
        } catch (error) {
          console.error('[MapTab] D3.js åœ°åœ–å‰µå»ºå¤±æ•—:', error);
          return false;
        }
      };

      /**
       * ğŸš€ åˆå§‹åŒ–åœ°åœ–
       * æ ¹æ“šåˆå§‹é¡¯ç¤ºæ¨¡å¼å‰µå»ºå°æ‡‰çš„è¦–åœ–
       */
      const initMap = async () => {
        let attempts = 0;
        const maxAttempts = 20;

        // æ ¹æ“šé¡¯ç¤ºæ¨¡å¼è¼‰å…¥ä¸åŒçš„æ•¸æ“š
        if (displayMode.value === 'map') {
          // åœ°åœ–æ¨¡å¼ï¼šéœ€è¦è¼‰å…¥ç¸£å¸‚ç•Œç·šå’Œå…­è§’å½¢ç¶²æ ¼æ•¸æ“š
          console.log('[MapTab] é–‹å§‹è¼‰å…¥åœ°åœ–æ¨¡å¼æ•¸æ“š...');
          const [countyLoaded, hexLoaded] = await Promise.all([loadCountyData(), loadHexData()]);

          if (!countyLoaded) {
            console.error('[MapTab] ç„¡æ³•è¼‰å…¥ç›´è½„å¸‚ã€ç¸£(å¸‚)ç•Œç·šæ•¸æ“š');
            return;
          }

          if (!hexLoaded) {
            console.error('[MapTab] ç„¡æ³•è¼‰å…¥å…­è§’å½¢ç¶²æ ¼æ•¸æ“š');
            return;
          }

          console.log('[MapTab] æ‰€æœ‰æ•¸æ“šè¼‰å…¥å®Œæˆï¼Œé–‹å§‹å‰µå»ºåœ°åœ–');

          const tryCreateMap = async () => {
            if (attempts >= maxAttempts) {
              console.error('[MapTab] åœ°åœ–åˆå§‹åŒ–å¤±æ•—ï¼Œå·²é”åˆ°æœ€å¤§å˜—è©¦æ¬¡æ•¸');
              return;
            }

            attempts++;
            console.log(`[MapTab] å˜—è©¦å‰µå»ºåœ°åœ– (${attempts}/${maxAttempts})`);

            if (createMap()) {
              console.log('[MapTab] åœ°åœ–å‰µå»ºæˆåŠŸï¼Œé–‹å§‹ç¹ªè£½åœ–å±¤');
              // å…ˆç¹ªè£½ç¸£å¸‚ç•Œç·šï¼ˆåº•å±¤ï¼‰
              drawCounties();
              // å†ç¹ªè£½å…­è§’å½¢ç¶²æ ¼ï¼ˆä¸Šå±¤ï¼‰
              drawHexGrid();
            } else {
              console.log('[MapTab] åœ°åœ–å‰µå»ºå¤±æ•—ï¼Œ100ms å¾Œé‡è©¦');
              setTimeout(tryCreateMap, 100);
            }
          };

          tryCreateMap();
        } else if (displayMode.value === 'grid') {
          // Grid æ¨¡å¼ï¼šéœ€è¦è¼‰å…¥å…­è§’å½¢ç¶²æ ¼æ•¸æ“šï¼Œéœ€è¦åœ°åœ–æŠ•å½±ä¾†ç¹ªè£½
          console.log('[MapTab] é–‹å§‹è¼‰å…¥ç¶²æ ¼æ¨¡å¼æ•¸æ“š...');
          const hexLoaded = await loadHexData();

          if (!hexLoaded) {
            console.error('[MapTab] ç„¡æ³•è¼‰å…¥å…­è§’å½¢ç¶²æ ¼æ•¸æ“š');
            return;
          }

          console.log('[MapTab] æ•¸æ“šè¼‰å…¥å®Œæˆï¼Œé–‹å§‹å‰µå»ºç¶²æ ¼è¦–åœ–');

          const tryCreateGrid = async () => {
            if (attempts >= maxAttempts) {
              console.error('[MapTab] ç¶²æ ¼åˆå§‹åŒ–å¤±æ•—ï¼Œå·²é”åˆ°æœ€å¤§å˜—è©¦æ¬¡æ•¸');
              return;
            }

            attempts++;
            console.log(`[MapTab] å˜—è©¦å‰µå»ºç¶²æ ¼è¦–åœ– (${attempts}/${maxAttempts})`);

            if (createMap()) {
              console.log('[MapTab] ç¶²æ ¼è¦–åœ–å‰µå»ºæˆåŠŸï¼Œé–‹å§‹ç¹ªè£½å…­è§’å½¢ç¶²æ ¼');
              drawHexGridOnly();
            } else {
              console.log('[MapTab] ç¶²æ ¼è¦–åœ–å‰µå»ºå¤±æ•—ï¼Œ100ms å¾Œé‡è©¦');
              setTimeout(tryCreateGrid, 100);
            }
          };

          tryCreateGrid();
        } else if (displayMode.value === 'cesium3d') {
          // CesiumJS 3D æ¨¡å¼
          console.log('[MapTab] é–‹å§‹è¼‰å…¥ CesiumJS 3D æ¨¡å¼æ•¸æ“š...');
          const [hexLoaded, countyLoaded] = await Promise.all([loadHexData(), loadCountyData()]);

          if (!hexLoaded) {
            console.error('[MapTab] ç„¡æ³•è¼‰å…¥å…­è§’å½¢ç¶²æ ¼æ•¸æ“š');
            return;
          }

          if (!countyLoaded) {
            console.error('[MapTab] ç„¡æ³•è¼‰å…¥ç¸£å¸‚ç•Œç·šæ•¸æ“š');
            return;
          }

          console.log('[MapTab] æ•¸æ“šè¼‰å…¥å®Œæˆï¼Œé–‹å§‹åˆå§‹åŒ– CesiumJS 3D åœ°åœ–');
          cleanupOtherViews();
          await initCesium3D();
        } else if (displayMode.value === 'maplibre3d') {
          // MapLibre 3D æ¨¡å¼
          console.log('[MapTab] é–‹å§‹è¼‰å…¥ MapLibre 3D æ¨¡å¼æ•¸æ“š...');
          const [hexLoaded, countyLoaded] = await Promise.all([loadHexData(), loadCountyData()]);

          if (!hexLoaded) {
            console.error('[MapTab] ç„¡æ³•è¼‰å…¥å…­è§’å½¢ç¶²æ ¼æ•¸æ“š');
            return;
          }

          if (!countyLoaded) {
            console.error('[MapTab] ç„¡æ³•è¼‰å…¥ç¸£å¸‚ç•Œç·šæ•¸æ“š');
            return;
          }

          console.log('[MapTab] æ•¸æ“šè¼‰å…¥å®Œæˆï¼Œé–‹å§‹åˆå§‹åŒ– MapLibre 3D åœ°åœ–');
          cleanupOtherViews();
          await initMapLibre3D();
        }
      };

      // è™•ç†çª—å£å¤§å°èª¿æ•´ï¼ˆé‡æ–°ç¹ªè£½æ•´å€‹åœ°åœ–ï¼‰
      let resizeTimer = null;
      const handleResize = () => {
        // é˜²æŠ–è™•ç†ï¼Œé¿å…é »ç¹é‡ç¹ª
        if (resizeTimer) {
          clearTimeout(resizeTimer);
        }
        resizeTimer = setTimeout(() => {
          console.log('[MapTab] çª—å£å¤§å°èª¿æ•´ï¼Œé‡æ–°ç¹ªè£½åœ°åœ–');
          initMap();
        }, 300);
      };

      // ğŸ§¹ ç”Ÿå‘½é€±æœŸï¼šçµ„ä»¶æ›è¼‰
      onMounted(() => {
        nextTick(() => {
          initMap();
        });

        // ç›£è½çª—å£å¤§å°èª¿æ•´
        window.addEventListener('resize', handleResize);
      });

      // ğŸ§¹ ç”Ÿå‘½é€±æœŸï¼šçµ„ä»¶å¸è¼‰
      onUnmounted(() => {
        // æ¸…é™¤ resize timer
        if (resizeTimer) {
          clearTimeout(resizeTimer);
        }

        // ç§»é™¤ resize ç›£è½å™¨
        window.removeEventListener('resize', handleResize);

        if (svg) {
          // å®Œå…¨ç§»é™¤ zoom è¡Œç‚º
          try {
            if (zoom) {
              svg.on('.zoom', null);
              svg.call(zoom.on('zoom', null));
            }
          } catch (e) {
            console.warn('[MapTab] ç§»é™¤ zoom è¡Œç‚ºæ™‚å‡ºéŒ¯:', e);
          }
          svg.remove();
          svg = null;
          g = null;
          zoom = null;
        }

        // æ¸…ç†å·¥å…·æç¤º
        if (tooltip) {
          tooltip.remove();
          tooltip = null;
        }

        // æ¸…ç† Cesium Viewer
        if (cesiumViewer) {
          try {
            cesiumViewer.destroy();
          } catch (e) {
            console.warn('[MapTab] æ¸…ç† Cesium Viewer æ™‚å‡ºéŒ¯:', e);
          }
          cesiumViewer = null;
        }

        // æ¸…ç† MapLibre Map
        if (maplibreMap) {
          try {
            maplibreMap.remove();
          } catch (e) {
            console.warn('[MapTab] æ¸…ç† MapLibre Map æ™‚å‡ºéŒ¯:', e);
          }
          maplibreMap = null;
        }

        projection = null;
        path = null;
        zoom = null;
        g = null;
        isMapReady.value = false;
      });

      // ğŸ“¤ è¿”å›çµ„ä»¶å…¬é–‹çš„å±¬æ€§å’Œæ–¹æ³•
      return {
        mapContainer,
        mapContainerId,
        displayMode,
        toggleDisplayMode,
      };
    },
  };
</script>

<template>
  <!-- ğŸ—ºï¸ åœ°åœ–ä¸»å®¹å™¨ -->
  <div id="map-container" class="h-100 w-100 position-relative bg-transparent z-0">
    <!-- ğŸ—ºï¸ Leaflet åœ°åœ–å®¹å™¨ -->
    <div :id="mapContainerId" ref="mapContainer" class="h-100 w-100"></div>

    <!-- ğŸ›ï¸ å·¦å´ä¸­é–“æ§åˆ¶é¢æ¿ -->
    <div
      class="position-absolute"
      style="top: 50%; left: 0; transform: translateY(-50%); z-index: 1000; padding: 1rem"
    >
      <div class="bg-dark bg-opacity-75 rounded-3 p-3">
        <!-- ğŸ›ï¸ é¡¯ç¤ºæ¨¡å¼é¸æ“‡å€åŸŸ -->
        <div class="">
          <div class="d-flex flex-column gap-1">
            <button
              type="button"
              class="btn border-0 my-country-btn my-font-sm-white px-4 py-3"
              :class="[displayMode === 'map' ? 'active' : '']"
              @click="toggleDisplayMode('map')"
            >
              åœ°åœ–æ¨¡å¼
            </button>
            <button
              type="button"
              class="btn border-0 my-country-btn my-font-sm-white px-4 py-3"
              :class="[displayMode === 'grid' ? 'active' : '']"
              @click="toggleDisplayMode('grid')"
            >
              ç¶²æ ¼æ¨¡å¼
            </button>
            <button
              type="button"
              class="btn border-0 my-country-btn my-font-sm-white px-4 py-3"
              :class="[displayMode === 'cesium3d' ? 'active' : '']"
              @click="toggleDisplayMode('cesium3d')"
            >
              CesiumJS 3Dæ¨¡å¼
            </button>
            <button
              type="button"
              class="btn border-0 my-country-btn my-font-sm-white px-4 py-3"
              :class="[displayMode === 'maplibre3d' ? 'active' : '']"
              @click="toggleDisplayMode('maplibre3d')"
            >
              MapLibre 3Dæ¨¡å¼
            </button>
            <button
              type="button"
              class="btn border-0 my-country-btn my-font-sm-white px-4 py-3"
              :class="[displayMode === 'map2' ? 'active' : '']"
              @click="toggleDisplayMode('map2')"
            >
              åœ°åœ–æ¨¡å¼2
            </button>
            <button
              type="button"
              class="btn border-0 my-country-btn my-font-sm-white px-4 py-3"
              :class="[displayMode === 'grid2' ? 'active' : '']"
              @click="toggleDisplayMode('grid2')"
            >
              ç¶²æ ¼æ¨¡å¼2
            </button>
            <button
              type="button"
              class="btn border-0 my-country-btn my-font-sm-white px-4 py-3"
              :class="[displayMode === 'cesium3d2' ? 'active' : '']"
              @click="toggleDisplayMode('cesium3d2')"
            >
              CesiumJS 3Dæ¨¡å¼2
            </button>
            <button
              type="button"
              class="btn border-0 my-country-btn my-font-sm-white px-4 py-3"
              :class="[displayMode === 'maplibre3d2' ? 'active' : '']"
              @click="toggleDisplayMode('maplibre3d2')"
            >
              MapLibre 3Dæ¨¡å¼2
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
  @import '../assets/css/common.css';

  #map-container {
    overflow: hidden;
  }

  /* CesiumJS å®¹å™¨æ¨£å¼ */
  :deep(.cesium-viewer) {
    width: 100%;
    height: 100%;
  }

  /* MapLibre GL å®¹å™¨æ¨£å¼ */
  :deep(.maplibregl-map) {
    width: 100%;
    height: 100%;
  }

  :deep(.maplibregl-popup-content) {
    background-color: rgba(0, 43, 127, 0.95);
    color: #ffc61e;
    border: 2px solid #ffc61e;
    padding: 10px;
    border-radius: 4px;
  }

  :deep(.leaflet-container) {
    background: #ffffff; /* ç™½è‰²èƒŒæ™¯ */
  }

  :deep(.leaflet-popup-content-wrapper) {
    background: rgba(0, 43, 127, 0.95); /* è«¾é­¯æ·±è—è‰²åŠé€æ˜ */
    color: #ffc61e; /* é‡‘é»ƒè‰²æ–‡å­— */
    border: 2px solid #ffc61e; /* é‡‘é»ƒè‰²é‚Šæ¡† */
  }

  :deep(.leaflet-popup-tip) {
    background: rgba(0, 43, 127, 0.95); /* è«¾é­¯æ·±è—è‰²åŠé€æ˜ */
  }

  :deep(.leaflet-tooltip) {
    background-color: rgba(0, 43, 127, 0.95) !important; /* è«¾é­¯æ·±è—è‰² */
    color: #ffc61e !important; /* é‡‘é»ƒè‰²æ–‡å­— */
    border: 1px solid #ffc61e !important; /* é‡‘é»ƒè‰²é‚Šæ¡† */
    font-size: 14px;
    padding: 8px 12px;
    border-radius: 4px;
    line-height: 1.4;
  }

  :deep(.map-tooltip) {
    background-color: #333; /* æ·±ç°è‰²èƒŒæ™¯ */
    color: #fff; /* ç™½è‰²æ–‡å­— */
    border: none; /* ç„¡é‚Šæ¡† */
  }
</style>
